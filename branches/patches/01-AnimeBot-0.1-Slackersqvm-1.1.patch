Index: src/game/g_local.h
===================================================================
--- src/game/g_local.h	(revision 92)
+++ src/game/g_local.h	(working copy)
@@ -87,6 +87,19 @@
 
 #define SP_PODIUM_MODEL   "models/mapobjects/podium/podium4.md3"
 
+typedef enum
+{
+  BOT_REGULAR = 1,
+  BOT_IDLE,
+  BOT_ATTACK,
+  BOT_STAND_GROUND,
+  BOT_DEFENSIVE,
+  BOT_FOLLOW_FRIEND_PROTECT,
+  BOT_FOLLOW_FRIEND_ATTACK,
+  BOT_FOLLOW_FRIEND_IDLE,
+  BOT_TEAM_KILLER
+} botCommand_t;
+
 //============================================================================
 
 struct gentity_s
@@ -200,6 +213,16 @@
 
   int               noise_index;
 
+  //for targeting following
+  botCommand_t		botCommand;
+  gentity_t         *botEnemy;
+  gentity_t         *botFriend;
+  int				botFriendLastSeen;  
+  int				botEnemyLastSeen;
+  int				botSkillLevel;
+  int				botTeam;
+
+
   // timing variables
   float             wait;
   float             random;
@@ -842,7 +865,21 @@
 void      G_SpawnEntitiesFromString( void );
 char      *G_NewString( const char *string );
 
+// g_bot.c
 //
+void G_BotAdd( char *name, int team, int skill );
+void G_BotDel( int clientNum );
+void G_BotCmd( gentity_t *master, int clientNum, char *command );
+void G_BotThink( gentity_t *self );
+void G_BotSpectatorThink( gentity_t *self );
+// todo: are these suppose to be out here?!
+qboolean botAimAtTarget( gentity_t *self, gentity_t *target );
+int botFindClosestEnemy( gentity_t *self, qboolean includeTeam );
+qboolean botTargetInRange( gentity_t *self, gentity_t *target );
+int botGetDistanceBetweenPlayer( gentity_t *self, gentity_t *player );
+qboolean botShootIfTargetInRange( gentity_t *self, gentity_t *target );
+
+//
 // g_cmds.c
 //
 void      Cmd_Score_f( gentity_t *ent );
@@ -1472,6 +1509,8 @@
 extern  vmCvar_t  mod_jetpackConsume;
 extern  vmCvar_t  mod_jetpackRegen;
 
+extern  vmCvar_t  g_bot_attackbuildables;
+
 extern  vmCvar_t  g_adminExpireTime;
 
 extern  vmCvar_t  g_autoGhost;
Index: src/game/g_active.c
===================================================================
--- src/game/g_active.c	(revision 92)
+++ src/game/g_active.c	(working copy)
@@ -388,6 +388,13 @@
   client->oldbuttons = client->buttons;
   client->buttons = ucmd->buttons;
 
+
+   //if bot
+   if( ent->r.svFlags & SVF_BOT ) {
+     G_BotSpectatorThink( ent );
+     return;
+   }
+
    attack1 = ( ( client->buttons & BUTTON_ATTACK ) &&
                !( client->oldbuttons & BUTTON_ATTACK ) );
    attack3 = ( ( client->buttons & BUTTON_USE_HOLDABLE ) &&
@@ -597,6 +604,10 @@
 
   while ( client->time100 >= 100 )
   {
+    if( ent->r.svFlags & SVF_BOT ) {
+      G_BotThink( ent );
+    }
+
     client->time100 -= 100;
 
     //if not trying to run then not trying to sprint
@@ -1893,14 +1904,14 @@
   // phone jack if they don't get any for a while
   ent->client->lastCmdTime = level.time;
 
-  if( !g_synchronousClients.integer )
+  if(  !( ent->r.svFlags & SVF_BOT ) && !g_synchronousClients.integer )
     ClientThink_real( ent );
 }
 
 
 void G_RunClient( gentity_t *ent )
 {
-  if( !g_synchronousClients.integer )
+  if(  !( ent->r.svFlags & SVF_BOT ) && !g_synchronousClients.integer )
     return;
 
   ent->client->pers.cmd.serverTime = level.time;
Index: src/game/g_public.h
===================================================================
--- src/game/g_public.h	(revision 92)
+++ src/game/g_public.h	(working copy)
@@ -35,6 +35,7 @@
 // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=551
 #define SVF_CLIENTMASK 0x00000002
 
+#define SVF_BOT                 0x00000008  // set if the entity is a bot
 #define SVF_BROADCAST           0x00000020  // send to all connected clients
 #define SVF_PORTAL              0x00000040  // merge a second pvs at origin2 into snapshots
 #define SVF_USE_CURRENT_ORIGIN  0x00000080  // entity->r.currentOrigin instead of entity->s.origin
Index: src/game/g_bot.c
===================================================================
--- src/game/g_bot.c	(revision 0)
+++ src/game/g_bot.c	(revision 0)
@@ -0,0 +1,620 @@
+/*
+===========================================================================
+Copyright (C) 2007 Amine Haddad
+
+This file is part of Tremulous.
+
+The original works of vcxzet (lamebot3) were used a guide to create TremBot.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+/* Current version: v0.01 */
+
+#include "g_local.h"
+
+void G_BotAdd( char *name, int team, int skill ) {
+  int i;
+  int clientNum;
+  char userinfo[MAX_INFO_STRING];
+  int reservedSlots = 0;
+  gentity_t *bot;
+
+  reservedSlots = trap_Cvar_VariableIntegerValue( "sv_privateclients" );
+
+  // find what clientNum to use for bot
+  clientNum = -1;
+  for( i = 0; i < reservedSlots; i++ ) {
+    if( !g_entities[i].inuse ) {
+      clientNum = i;
+      break;
+    }
+  }
+
+  if(clientNum < 0) {
+    trap_Printf("no more slots for bot\n");
+    return;
+  }
+
+  bot = &g_entities[ clientNum ];
+  bot->r.svFlags |= SVF_BOT;
+  bot->inuse = qtrue;
+
+  //default bot data
+  bot->botCommand = BOT_REGULAR;
+  bot->botFriend = NULL;
+  bot->botEnemy = NULL;
+  bot->botFriendLastSeen = 0;
+  bot->botEnemyLastSeen = 0;
+  bot->botSkillLevel = skill;
+  bot->botTeam = team;
+
+  // register user information
+  userinfo[0] = '\0';
+  Info_SetValueForKey( userinfo, "name", name );
+  Info_SetValueForKey( userinfo, "rate", "25000" );
+  Info_SetValueForKey( userinfo, "snaps", "20" );
+  Info_SetValueForKey( userinfo, "ip", "1.2.3.4" );
+  if( *g_password.string && Q_stricmp( g_password.string, "none" ) )
+    Info_SetValueForKey( userinfo, "password", g_password.string );
+
+  trap_SetUserinfo( clientNum, userinfo );
+
+  // have it connect to the game as a normal client
+  if(ClientConnect(clientNum, qtrue) != NULL ) {
+    // won't let us join
+    return;
+  }
+
+  ClientBegin( clientNum );
+  G_ChangeTeam( bot, team );
+}
+
+void G_BotDel( int clientNum ) {
+  gentity_t *bot;
+
+  bot = &g_entities[clientNum];
+  if( !( bot->r.svFlags & SVF_BOT ) ) {
+    trap_Printf( va("'^7%s^7' is not a bot\n", bot->client->pers.netname) );
+    return;
+  }
+
+  ClientDisconnect(clientNum);
+}
+
+void G_BotCmd( gentity_t *master, int clientNum, char *command ) {
+  gentity_t *bot;
+
+  bot = &g_entities[clientNum];
+  if( !( bot->r.svFlags & SVF_BOT ) ) {
+    return;
+  }
+
+  bot->botFriend = NULL;
+  bot->botEnemy = NULL;
+  bot->botFriendLastSeen = 0;
+  bot->botEnemyLastSeen = 0;
+
+  if( !Q_stricmp( command, "regular" ) ) {
+    bot->botCommand = BOT_REGULAR;
+    //trap_SendServerCommand(-1, "print \"regular mode\n\"");
+  } else if( !Q_stricmp( command, "idle" ) ) {
+    bot->botCommand = BOT_IDLE;
+    //trap_SendServerCommand(-1, "print \"idle mode\n\"");
+  } else if( !Q_stricmp( command, "attack" ) ) {
+    bot->botCommand = BOT_ATTACK;
+    //trap_SendServerCommand(-1, "print \"attack mode\n\"");
+  } else if( !Q_stricmp( command, "standground" ) ) {
+    bot->botCommand = BOT_STAND_GROUND;
+    //trap_SendServerCommand(-1, "print \"stand ground mode\n\"");
+  } else if( !Q_stricmp( command, "defensive" ) ) {
+    bot->botCommand = BOT_DEFENSIVE;
+    //trap_SendServerCommand(-1, "print \"defensive mode\n\"");
+  } else if( !Q_stricmp( command, "followprotect" ) ) {
+    bot->botCommand = BOT_FOLLOW_FRIEND_PROTECT;
+    bot->botFriend = master;
+    //trap_SendServerCommand(-1, "print \"follow-protect mode\n\"");
+  } else if( !Q_stricmp( command, "followattack" ) ) {
+    bot->botCommand = BOT_FOLLOW_FRIEND_ATTACK;
+    bot->botFriend = master;
+    //trap_SendServerCommand(-1, "print \"follow-attack mode\n\"");
+  } else if( !Q_stricmp( command, "followidle" ) ) {
+    bot->botCommand = BOT_FOLLOW_FRIEND_IDLE;
+    bot->botFriend = master;
+    //trap_SendServerCommand(-1, "print \"follow-idle mode\n\"");
+  } else if( !Q_stricmp( command, "teamkill" ) ) {
+    bot->botCommand = BOT_TEAM_KILLER;
+    //trap_SendServerCommand(-1, "print \"team kill mode\n\"");
+  } else {
+    bot->botCommand = BOT_REGULAR;
+    //trap_SendServerCommand(-1, "print \"regular (unknown) mode\n\"");
+  }
+
+  return;
+}
+
+void G_BotThink( gentity_t *self )
+{
+  int distance = 0;
+  int clicksToStopChase = 30; //5 seconds
+  int tooCloseDistance = 100; // about 1/3 of turret range
+  int forwardMove = 127; // max speed
+  int tempEntityIndex = -1;
+  qboolean followFriend = qfalse;
+
+  self->client->pers.cmd.buttons = 0;
+  self->client->pers.cmd.forwardmove = 0;
+  self->client->pers.cmd.upmove = 0;
+  self->client->pers.cmd.rightmove = 0;
+
+  // reset botEnemy if enemy is dead
+  if(self->botEnemy->health <= 0) {
+    self->botEnemy = NULL;
+  }
+
+  // if friend dies, reset status to regular
+  if(self->botFriend->health <= 0) {
+    self->botCommand = BOT_REGULAR;
+    self->botFriend = NULL;
+  }
+
+  // what mode are we in?
+  switch(self->botCommand) {
+    case BOT_REGULAR:
+      // if there is enemy around, rush them and attack.
+      if(self->botEnemy) {
+         // we already have an enemy. See if still in LOS.
+        if(!botTargetInRange(self,self->botEnemy)) {
+          // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
+          if(self->botEnemyLastSeen > clicksToStopChase) {
+                                                // forget him!
+            self->botEnemy = NULL;
+            self->botEnemyLastSeen = 0;
+          } else {
+            //chase him
+            self->botEnemyLastSeen++;
+          }
+        } else {
+          // we see him!
+          self->botEnemyLastSeen = 0;
+        }
+      }
+
+      if(!self->botEnemy) {
+        // try to find closest enemy
+        tempEntityIndex = botFindClosestEnemy(self, qfalse);
+        if(tempEntityIndex >= 0)
+          self->botEnemy = &g_entities[tempEntityIndex];
+      }
+
+      if(!self->botEnemy) {
+        // no enemy
+      } else {
+        // enemy!
+        distance = botGetDistanceBetweenPlayer(self, self->botEnemy);
+        botAimAtTarget(self, self->botEnemy);
+
+        // enable wallwalk
+        if( BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) {
+          self->client->pers.cmd.upmove = -1;
+        }
+
+        botShootIfTargetInRange(self,self->botEnemy);
+        self->client->pers.cmd.forwardmove = forwardMove;
+        self->client->pers.cmd.rightmove = -100;
+        if(self->client->time1000 >= 500)
+          self->client->pers.cmd.rightmove = 100;
+      }
+      break;
+    case BOT_IDLE:
+      // just stand there and look pretty.
+      break;
+    case BOT_ATTACK:
+      // .. not sure ..
+      break;
+    case BOT_STAND_GROUND:
+       // stand ground but attack enemies if you can reach.
+      if(self->botEnemy) {
+        // we already have an enemy. See if still in LOS.
+        if(!botTargetInRange(self,self->botEnemy)) {
+          //we are not in LOS
+          self->botEnemy = NULL;
+        }
+      }
+      if(!self->botEnemy) {
+        // try to find closest enemy
+        tempEntityIndex = botFindClosestEnemy(self, qfalse);
+        if(tempEntityIndex >= 0)
+          self->botEnemy = &g_entities[tempEntityIndex];
+      }
+      if(!self->botEnemy) {
+        // no enemy
+      } else {
+        // enemy!
+        distance = botGetDistanceBetweenPlayer(self, self->botEnemy);
+        botAimAtTarget(self, self->botEnemy);
+
+        // enable wallwalk
+        if( BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) {
+          self->client->pers.cmd.upmove = -1;
+        }
+
+        botShootIfTargetInRange(self,self->botEnemy);
+      }
+      break;
+    case BOT_DEFENSIVE:
+      // if there is an enemy around, rush them but not too far from where you are standing when given this command
+      break;
+    case BOT_FOLLOW_FRIEND_PROTECT:
+      // run towards friend, attack enemy
+      break;
+    case BOT_FOLLOW_FRIEND_ATTACK:
+      // run with friend until enemy spotted, then rush enemy
+      if(self->botEnemy) {
+        // we already have an enemy. See if still in LOS.
+        if(!botTargetInRange(self,self->botEnemy)) {
+          // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
+          if(self->botEnemyLastSeen > clicksToStopChase) {
+            // forget him!
+            self->botEnemy = NULL;
+            self->botEnemyLastSeen = 0;
+          } else {
+            //chase him
+            self->botEnemyLastSeen++;
+          }
+        } else {
+          // we see him!
+          self->botEnemyLastSeen = 0;
+        }
+
+        //if we are chasing enemy, reset counter for friend LOS .. if its true
+        if(self->botEnemy) {
+          if(botTargetInRange(self,self->botFriend)) {
+            self->botFriendLastSeen = 0;
+          } else {
+            self->botFriendLastSeen++;
+          }
+        }
+      }
+
+      if(!self->botEnemy) {
+        // try to find closest enemy
+        tempEntityIndex = botFindClosestEnemy(self, qfalse);
+        if(tempEntityIndex >= 0)
+          self->botEnemy = &g_entities[tempEntityIndex];
+      }
+
+      if(!self->botEnemy) {
+        // no enemy
+        if(self->botFriend) {
+          // see if our friend is in LOS
+          if(botTargetInRange(self,self->botFriend)) {
+            // go to him!
+            followFriend = qtrue;
+            self->botFriendLastSeen = 0;
+          } else {
+            // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
+            if(self->botFriendLastSeen > clicksToStopChase) {
+              // forget him!
+              followFriend = qfalse;
+            } else {
+              self->botFriendLastSeen++;
+              followFriend = qtrue;
+            }
+          }
+
+          if(followFriend) {
+            distance = botGetDistanceBetweenPlayer(self, self->botFriend);
+            botAimAtTarget(self, self->botFriend);
+
+            // enable wallwalk
+            if( BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) {
+              self->client->pers.cmd.upmove = -1;
+            }
+
+            //botShootIfTargetInRange(self,self->botEnemy);
+            if(distance>tooCloseDistance) {
+              self->client->pers.cmd.forwardmove = forwardMove;
+              self->client->pers.cmd.rightmove = -100;
+              if(self->client->time1000 >= 500)
+                self->client->pers.cmd.rightmove = 100;
+            }
+          }
+        }
+      } else {
+        // enemy!
+        distance = botGetDistanceBetweenPlayer(self, self->botEnemy);
+        botAimAtTarget(self, self->botEnemy);
+
+        // enable wallwalk
+        if( BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) {
+          self->client->pers.cmd.upmove = -1;
+        }
+
+        botShootIfTargetInRange(self,self->botEnemy);
+        self->client->pers.cmd.forwardmove = forwardMove;
+        self->client->pers.cmd.rightmove = -100;
+        if(self->client->time1000 >= 500)
+          self->client->pers.cmd.rightmove = 100;
+      }
+      break;
+    case BOT_FOLLOW_FRIEND_IDLE:
+      // run with friend and stick with him no matter what. no attack mode.
+      if(self->botFriend) {
+        // see if our friend is in LOS
+        if(botTargetInRange(self,self->botFriend)) {
+          // go to him!
+          followFriend = qtrue;
+          self->botFriendLastSeen = 0;
+        } else {
+          // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
+          if(self->botFriendLastSeen > clicksToStopChase) {
+                                                // forget him!
+            followFriend = qfalse;
+          } else {
+                                                //chase him
+            self->botFriendLastSeen++;
+            followFriend = qtrue;
+          }
+        }
+
+        if(followFriend) {
+          distance = botGetDistanceBetweenPlayer(self, self->botFriend);
+          botAimAtTarget(self, self->botFriend);
+
+          // enable wallwalk
+          if( BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) {
+            self->client->pers.cmd.upmove = -1;
+          }
+
+          //botShootIfTargetInRange(self,self->botFriend);
+          if(distance>tooCloseDistance) {
+            self->client->pers.cmd.forwardmove = forwardMove;
+            self->client->pers.cmd.rightmove = -100;
+            if(self->client->time1000 >= 500)
+              self->client->pers.cmd.rightmove = 100;
+          }
+        }
+      }
+      break;
+    case BOT_TEAM_KILLER:
+      // attack enemies, then teammates!
+      if(self->botEnemy) {
+        // we already have an enemy. See if still in LOS.
+        if(!botTargetInRange(self,self->botEnemy)) {
+          // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
+          if(self->botEnemyLastSeen > clicksToStopChase) {
+            // forget him!
+            self->botEnemy = NULL;
+            self->botEnemyLastSeen = 0;
+          } else {
+            //chase him
+            self->botEnemyLastSeen++;
+          }
+        } else {
+          // we see him!
+          self->botEnemyLastSeen = 0;
+        }
+      }
+
+      if(!self->botEnemy) {
+        // try to find closest enemy
+        tempEntityIndex = botFindClosestEnemy(self, qtrue);
+        if(tempEntityIndex >= 0)
+          self->botEnemy = &g_entities[tempEntityIndex];
+      }
+
+      if(!self->botEnemy) {
+        // no enemy, we're all alone :(
+      } else {
+        // enemy!
+        distance = botGetDistanceBetweenPlayer(self, self->botEnemy);
+        botAimAtTarget(self, self->botEnemy);
+
+        // enable wallwalk
+        if( BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) {
+          self->client->pers.cmd.upmove = -1;
+        }
+
+        botShootIfTargetInRange(self,self->botEnemy);
+        self->client->pers.cmd.forwardmove = forwardMove;
+        self->client->pers.cmd.rightmove = -100;
+        if(self->client->time1000 >= 500)
+          self->client->pers.cmd.rightmove = 100;
+      }
+      break;
+    default:
+      // dunno.
+      break;
+  }
+}
+
+void G_BotSpectatorThink( gentity_t *self ) {
+  if( self->client->ps.pm_flags & PMF_QUEUED) {
+    //we're queued to spawn, all good
+    return;
+  }
+
+  if( self->client->sess.sessionTeam == TEAM_SPECTATOR ) {
+    int teamnum = self->client->pers.teamSelection;
+    int clientNum = self->client->ps.clientNum;
+
+    if( teamnum == PTE_HUMANS ) {
+      self->client->pers.classSelection = PCL_HUMAN;
+      self->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
+      self->client->pers.humanItemSelection = WP_MACHINEGUN;
+      G_PushSpawnQueue( &level.humanSpawnQueue, clientNum );
+    } else if( teamnum == PTE_ALIENS) {
+      self->client->pers.classSelection = PCL_ALIEN_LEVEL0;
+      self->client->ps.stats[ STAT_PCLASS ] = PCL_ALIEN_LEVEL0;
+      G_PushSpawnQueue( &level.alienSpawnQueue, clientNum );
+    }
+  }
+}
+
+qboolean botAimAtTarget( gentity_t *self, gentity_t *target ) {
+  vec3_t dirToTarget, angleToTarget;
+  vec3_t top = { 0, 0, 0};
+  int vh = 0;
+  BG_FindViewheightForClass(  self->client->ps.stats[ STAT_PCLASS ], &vh, NULL );
+  top[2]=vh;
+  VectorAdd( self->s.pos.trBase, top, top);
+  VectorSubtract( target->s.pos.trBase, top, dirToTarget );
+  VectorNormalize( dirToTarget );
+  vectoangles( dirToTarget, angleToTarget );
+  self->client->ps.delta_angles[ 0 ] = ANGLE2SHORT( angleToTarget[ 0 ] );
+  self->client->ps.delta_angles[ 1 ] = ANGLE2SHORT( angleToTarget[ 1 ] );
+  self->client->ps.delta_angles[ 2 ] = ANGLE2SHORT( angleToTarget[ 2 ] );
+  return qtrue;
+}
+
+qboolean botTargetInRange( gentity_t *self, gentity_t *target ) {
+  trace_t   trace;
+  gentity_t *traceEnt;
+  //int myGunRange;
+  //myGunRange = MGTURRET_RANGE * 3;
+
+  if( !self || !target )
+    return qfalse;
+
+  if( !self->client || ( !target->client && g_bot_attackbuildables.integer == 0 ) )
+    return qfalse;
+
+  if( target->client->ps.stats[ STAT_STATE ] & SS_HOVELING )
+    return qfalse;
+
+  if( target->health <= 0 )
+    return qfalse;
+  //if( Distance( self->s.pos.trBase, target->s.pos.trBase ) > myGunRange )
+  //	return qfalse;
+
+  //draw line between us and the target and see what we hit
+  trap_Trace( &trace, self->s.pos.trBase, NULL, NULL, target->s.pos.trBase, self->s.number, MASK_SHOT );
+  traceEnt = &g_entities[ trace.entityNum ];
+
+  // check that we hit a human and not an object
+  //if( !traceEnt->client )
+  //	return qfalse;
+
+  //check our target is in LOS
+  if(!(traceEnt == target))
+    return qfalse;
+
+  return qtrue;
+}
+
+int botFindClosestEnemy( gentity_t *self, qboolean includeTeam ) {
+  // return enemy entity index, or -1
+  int vectorRange = MGTURRET_RANGE * 3;	
+  int i;
+  int total_entities;
+  int entityList[ MAX_GENTITIES ];
+  vec3_t    range;
+  vec3_t    mins, maxs;
+  gentity_t *target;
+
+  VectorSet( range, vectorRange, vectorRange, vectorRange );
+  VectorAdd( self->client->ps.origin, range, maxs );
+  VectorSubtract( self->client->ps.origin, range, mins );
+
+  total_entities = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
+
+  // check list for enemies
+  for( i = 0; i < total_entities; i++ ) {
+    target = &g_entities[ entityList[ i ] ];
+
+    if ( g_bot_attackbuildables.integer == 0 )
+    {
+      if (target->client && self != target && target->client->ps.stats[ STAT_PTEAM ] != self->client->ps.stats[ STAT_PTEAM ])
+      {
+                        // aliens ignore if it's in LOS because they have radar
+                        //if(self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS) {
+                        //	return entityList[ i ];
+                        //} else {
+        if( botTargetInRange( self, target ) ) {
+          return entityList[ i ];
+        }
+                        //}
+      }
+    }
+    else if ( g_bot_attackbuildables.integer == 1 )
+    {
+      if ((target->client && self != target && target->client->ps.stats[ STAT_PTEAM ] != self->client->ps.stats[ STAT_PTEAM ])
+           || (!target->client && self != target && self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && self->client->ps.stats[ STAT_PCLASS ] != PCL_ALIEN_LEVEL0 &&
+           (target->s.modelindex == BA_H_SPAWN
+           || target->s.modelindex == BA_H_MGTURRET
+           || target->s.modelindex == BA_H_TESLAGEN
+           || target->s.modelindex == BA_H_ARMOURY
+           || target->s.modelindex == BA_H_DCC
+           || target->s.modelindex == BA_H_MEDISTAT
+           || target->s.modelindex == BA_H_REACTOR
+           || target->s.modelindex == BA_H_REPEATER)) ||
+           (!target->client && self != target && self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && (
+             target->s.modelindex == BA_A_SPAWN ||
+           target->s.modelindex == BA_A_BARRICADE ||
+           target->s.modelindex == BA_A_BOOSTER ||
+           target->s.modelindex == BA_A_ACIDTUBE ||
+           target->s.modelindex == BA_A_HIVE ||
+           target->s.modelindex == BA_A_TRAPPER ||
+           target->s.modelindex == BA_A_OVERMIND ||
+           target->s.modelindex == BA_A_HOVEL)) || (!target->client && self != target && self->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_LEVEL0 && (target->s.modelindex == BA_H_MGTURRET)))
+      {
+                        // aliens ignore if it's in LOS because they have radar
+                        //if(self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS) {
+                        //	return entityList[ i ];
+                        //} else {
+        if( botTargetInRange( self, target ) ) {
+          return entityList[ i ];
+        }
+                        //}
+      }
+    }
+  }
+
+  if(includeTeam) {
+    // check list for enemies in team
+    for( i = 0; i < total_entities; i++ ) {
+      target = &g_entities[ entityList[ i ] ];
+
+      if( target->client && self !=target && target->client->ps.stats[ STAT_PTEAM ] == self->client->ps.stats[ STAT_PTEAM ] ) {
+        // aliens ignore if it's in LOS because they have radar
+        if(self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS) {
+          return entityList[ i ];
+        } else {
+          if( botTargetInRange( self, target ) ) {
+            return entityList[ i ];
+          }
+        }
+      }
+    }
+  }
+
+  return -1;
+}
+
+// really an int? what if it's too long?
+int botGetDistanceBetweenPlayer( gentity_t *self, gentity_t *player ) {
+  return Distance( self->s.pos.trBase, player->s.pos.trBase );
+}
+
+qboolean botShootIfTargetInRange( gentity_t *self, gentity_t *target ) {
+  if(botTargetInRange(self,target)) {
+    self->client->pers.cmd.buttons |= BUTTON_ATTACK;
+    return qtrue;
+  }
+  return qfalse;
+}
+
Index: src/game/g_main.c
===================================================================
--- src/game/g_main.c	(revision 92)
+++ src/game/g_main.c	(working copy)
@@ -218,11 +218,12 @@
 vmCvar_t  g_welcomeMsg;
 vmCvar_t  g_welcomeMsgTime;
 
-
 vmCvar_t  mod_jetpackFuel;
 vmCvar_t  mod_jetpackConsume;
 vmCvar_t  mod_jetpackRegen;
 
+vmCvar_t  g_bot_attackbuildables;
+
 vmCvar_t  g_adminExpireTime;
 
 vmCvar_t  g_autoGhost;
@@ -437,6 +438,8 @@
   { &mod_jetpackConsume, "mod_jetpackConsume", "2", CVAR_ARCHIVE, 0, qfalse  },
   { &mod_jetpackRegen, "mod_jetpackRegen", "3", CVAR_ARCHIVE, 0, qfalse  },
 
+  { &g_bot_attackbuildables, "g_bot_attackbuildables", "1", CVAR_ARCHIVE, 0, qfalse },
+
   { &g_teamKillThreshold, "g_teamKillThreshold", "0", CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_aimbotAdvertBan, "g_aimbotAdvertBan", "0", CVAR_ARCHIVE, 0, qfalse  },
Index: src/game/g_admin.c
===================================================================
--- src/game/g_admin.c	(revision 92)
+++ src/game/g_admin.c	(working copy)
@@ -66,7 +66,7 @@
       "restore a player's ability to use a weapon or class",
       "[^3name|slot#^7] [^3class|weapon|all^7]"
     },
-    
+
     {"allready", G_admin_allready, "allready",
       "makes everyone ready in intermission",
       ""
@@ -80,6 +80,16 @@
       "[^3name|slot#|IP^7] (^5time^7) (^5reason^7)"
     },
 
+    {"bot", G_admin_bot, "bot",
+      "Add or delete bot(s)",
+      "[^3add/del^7] [name] [^5aliens/humans^7] (skill)"
+    },
+
+    {"botcmd", G_admin_botcmd, "bot",
+      "Change bot behavior.",
+      "[^3name^7] [^5regular/idle/attack/standground/defensive/followprotect/followattack/followidle/teamkill^7]"
+    },
+
     {"buildlog", G_admin_buildlog, "buildlog",
       "display a list of recent builds and deconstructs, optionally specifying"
       " a team",
@@ -2654,6 +2664,132 @@
   return qtrue;
 }
 
+qboolean G_admin_bot( gentity_t *ent, int skiparg ) {
+	// add [name] (team) (skill)
+	// del [name]
+	int minargc;
+	
+	char command[10];
+	char name[ MAX_NAME_LENGTH ];
+	char name_s[ MAX_NAME_LENGTH ];
+	//char name2[ MAX_NAME_LENGTH ];
+	char name2_s[ MAX_NAME_LENGTH ];
+	char team[10];
+	int team_int;
+	char skill[2];
+	int skill_int;
+	qboolean success = qfalse;
+	int i, j;
+	
+	//char s2[ MAX_NAME_LENGTH ];
+	//char n2[ MAX_NAME_LENGTH ];
+	//int logmatch = -1, logmatches = 0;
+	//int i, j;
+	//qboolean exactmatch = qfalse;
+	
+	minargc = 3 + skiparg;
+	if( G_SayArgc() < minargc )	{
+		ADMP( "^7Please have at least command and name.\n" );
+		ADMP( "^3!bot: ^7usage: !bot [add/del] [name] (team) (skill)\n" );
+		return qfalse;
+	}
+
+	G_SayArgv( 1 + skiparg, command, sizeof( command ) );
+	G_SayArgv( 2 + skiparg, name, sizeof( name ) );
+	G_SanitiseString( name, name_s, sizeof( name_s ) );
+	
+	if(!Q_stricmp(command,"add")) {
+		// add [name] [team] (skill)
+		minargc = 4 + skiparg;
+		if( G_SayArgc() < minargc )	{
+			ADMP( "^7Please have at least name and team.\n" );
+			ADMP( "^3!bot: ^7usage: !bot [add/del] [name] [humans/aliens] (skill)\n" );
+			return qfalse;
+		}
+		
+		G_SayArgv( 3 + skiparg, team, sizeof( team ) );
+		
+		if(!Q_stricmp(team,"humans")) {
+			team_int = PTE_HUMANS;
+		} else if(!Q_stricmp(team,"aliens")) {
+			team_int = PTE_ALIENS;
+		} else {
+			ADMP( "^7Invalid bot team.\n" );
+			ADMP( "^3!bot: ^7usage: !bot add [name] [humans/aliens] (skill)\n" );
+			return qfalse;
+		}
+		
+		minargc = 5 + skiparg;
+		if(G_SayArgc() < minargc) {
+			skill_int = 0;
+		} else {
+			G_SayArgv( 4 + skiparg, skill, sizeof( skill ) );
+			skill_int = atoi(skill);
+		}
+		
+		// got name, team_int and skill_int
+		G_BotAdd(name, team_int, skill_int);
+		return qtrue;
+	} else if(!Q_stricmp(command,"del")) {
+		// del [name]
+		success = qfalse;
+		for( i = 0; i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ];i++ ) {
+			if( g_admin_namelog[ i ]->slot >= 0 ) {
+				for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES && g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ ) {
+					G_SanitiseString(g_admin_namelog[ i ]->name[ j ], name2_s, sizeof( name2_s ) );
+					if( strstr( name2_s, name_s ) ) {
+						G_BotDel(g_admin_namelog[ i ]->slot);
+						success = qtrue;
+					}
+				}
+			}
+		}
+		
+		return success;
+		//ADMP( "delete not implemented yet\n" );
+		//return qfalse;
+	}
+	
+	ADMP( "^3!bot: ^7usage: !bot [add/del] [name] (team) (skill)\n" );
+	return qfalse;
+}
+
+qboolean G_admin_botcmd( gentity_t *ent, int skiparg ) {
+	int minargc;
+	char name[ MAX_NAME_LENGTH ];
+	char name_s[ MAX_NAME_LENGTH ];
+	char name2_s[ MAX_NAME_LENGTH ];
+	char command[ 32 ];
+	int i, j;
+	qboolean success = qfalse;
+	
+	//[botname] [command]
+	minargc = 3 + skiparg;
+	if( G_SayArgc() < minargc )	{
+		ADMP( "^3!botcmd: ^7usage: !botcmd [botname] [command]\n" );
+		return qfalse;
+	}
+	
+	G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+	G_SayArgv( 2 + skiparg, command, sizeof( command ) );
+	G_SanitiseString( name, name_s, sizeof( name_s ) );
+	
+	success = qfalse;
+	for( i = 0; i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ];i++ ) {
+		if( g_admin_namelog[ i ]->slot >= 0 ) {
+			for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES && g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ ) {
+				G_SanitiseString(g_admin_namelog[ i ]->name[ j ], name2_s, sizeof( name2_s ) );
+				if( strstr( name2_s, name_s ) ) {
+					G_BotCmd(ent, g_admin_namelog[ i ]->slot,command);
+					success = qtrue;
+				}
+			}
+		}
+	}
+	
+	return success;
+}
+
 qboolean G_admin_ban( gentity_t *ent, int skiparg )
 {
   int seconds;
Index: src/game/g_admin.h
===================================================================
--- src/game/g_admin.h	(revision 92)
+++ src/game/g_admin.h	(working copy)
@@ -199,6 +199,8 @@
 void G_admin_seen_update( char *guid );
 
 // ! command functions
+qboolean G_admin_bot( gentity_t *ent, int skiparg );
+qboolean G_admin_botcmd( gentity_t *ent, int skiparg );
 qboolean G_admin_time( gentity_t *ent, int skiparg );
 qboolean G_admin_setlevel( gentity_t *ent, int skiparg );
 qboolean G_admin_flaglist( gentity_t *ent, int skiparg );
Index: src/game/g_cmds.c
===================================================================
--- src/game/g_cmds.c	(revision 92)
+++ src/game/g_cmds.c	(working copy)
@@ -1659,6 +1659,8 @@
  
   if( !Q_stricmp( arg1, "kick" ) )
   {
+    gentity_t *bot;
+
     if( G_admin_permission( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
     {
       trap_SendServerCommand( ent-g_entities,
@@ -1668,6 +1670,15 @@
       return;
     }
 
+
+    bot = &g_entities[ clientNum ];
+    if( ( bot->r.svFlags & SVF_BOT ) )
+    {
+      trap_SendServerCommand( ent-g_entities,
+           "print \"callvote: you can't kick bots\n\"" );
+      return;
+     }
+
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.voteString, sizeof( level.voteString ),
       "!ban %s \"%s\" vote kick", level.clients[ clientNum ].pers.ip,
@@ -2302,6 +2313,8 @@
 
   if( !Q_stricmp( arg1, "kick" ) )
   {
+    gentity_t *bot;
+
     if( G_admin_permission( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
     {
       trap_SendServerCommand( ent-g_entities,
@@ -2311,6 +2324,13 @@
       return;
     }
 
+    bot = &g_entities[ clientNum ];
+    if( ( bot->r.svFlags & SVF_BOT ) )
+    {
+      trap_SendServerCommand( ent-g_entities,
+           "print \"callvote: you can't kick bots\n\"" );
+      return;
+     }
 
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.teamVoteString[ cs_offset ],
Index: Makefile
===================================================================
--- Makefile	(revision 92)
+++ Makefile	(working copy)
@@ -864,6 +864,7 @@
   $(B)/base/game/g_ptr.o \
   $(B)/base/game/g_weapon.o \
   $(B)/base/game/g_admin.o \
+  $(B)/base/game/g_bot.o \
   \
   $(B)/base/qcommon/q_math.o \
   $(B)/base/qcommon/q_shared.o
