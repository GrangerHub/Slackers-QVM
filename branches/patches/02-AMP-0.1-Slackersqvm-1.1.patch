Index: src/game/g_spawn.c
===================================================================
--- src/game/g_spawn.c	(revision 92)
+++ src/game/g_spawn.c	(working copy)
@@ -123,7 +123,15 @@
   {"spawnflags", FOFS(spawnflags), F_INT},
   {"speed", FOFS(speed), F_FLOAT},
   {"target", FOFS(target), F_LSTRING},
+  {"target", FOFS(multitarget[ 0 ]), F_LSTRING},
+  {"target2", FOFS(multitarget[ 1 ]), F_LSTRING},
+  {"target3", FOFS(multitarget[ 2 ]), F_LSTRING},
+  {"target4", FOFS(multitarget[ 3 ]), F_LSTRING},
   {"targetname", FOFS(targetname), F_LSTRING},
+  {"targetname", FOFS(multitargetname[ 0 ]), F_LSTRING},
+  {"targetname2", FOFS(multitargetname[ 1 ]), F_LSTRING},
+  {"targetname3", FOFS(multitargetname[ 2 ]), F_LSTRING},
+  {"targetname4", FOFS(multitargetname[ 3 ]), F_LSTRING},
   {"message", FOFS(message), F_LSTRING},
   {"team", FOFS(team), F_LSTRING},
   {"wait", FOFS(wait), F_FLOAT},
@@ -142,7 +150,15 @@
   {"rotatorAngle", FOFS(rotatorAngle), F_FLOAT},
   {"targetShaderName", FOFS(targetShaderName), F_LSTRING},
   {"targetShaderNewName", FOFS(targetShaderNewName), F_LSTRING},
-
+  // ==Troy== AMP begin
+  {"cvar", FOFS(Cvar_Val), F_LSTRING},
+  {"sign", FOFS(sign), F_LSTRING},
+  {"inventory", FOFS(inventory), F_LSTRING},
+  {"class", FOFS(inventory), F_LSTRING},
+  {"weapon", FOFS(inventory), F_LSTRING},
+  {"gate", FOFS(TargetGate), F_LSTRING},
+  // ==Troy== AMP end
+  
   {NULL}
 };
 
@@ -176,6 +192,10 @@
 void SP_func_door_model( gentity_t *ent );
 void SP_func_train( gentity_t *ent );
 void SP_func_timer( gentity_t *self);
+// ==Troy== AMP definition of the triggers BEGIN
+void SP_func_destructable( gentity_t *self);
+void SP_func_spawn( gentity_t *self);
+// ==Troy== AMP definition of the triggers END
 
 void SP_trigger_always( gentity_t *ent );
 void SP_trigger_multiple( gentity_t *ent );
@@ -190,7 +210,10 @@
 void SP_trigger_gravity( gentity_t *ent );
 void SP_trigger_heal( gentity_t *ent );
 void SP_trigger_ammo( gentity_t *ent );
+// ==Troy== AMP definition of the triggers BEGIN
+// ==Troy== AMP definition of the triggers END
 
+
 void SP_target_delay( gentity_t *ent );
 void SP_target_speaker( gentity_t *ent );
 void SP_target_print( gentity_t *ent );
@@ -206,7 +229,25 @@
 void SP_target_alien_win( gentity_t *ent );
 void SP_target_human_win( gentity_t *ent );
 void SP_target_hurt( gentity_t *ent );
+// ==Troy== AMP definition of the targets BEGIN
+void SP_target_and( gentity_t *ent );
+void SP_target_or( gentity_t *ent );
+void SP_target_xor( gentity_t *ent );
+void SP_target_count( gentity_t *ent );
+void SP_target_stgctrl( gentity_t *ent );
+void SP_target_if( gentity_t *ent );
+void SP_target_fund( gentity_t *ent );
+void SP_target_force_weapon( gentity_t *ent );
+void SP_target_force_class( gentity_t *ent );
+void SP_target_force_win( gentity_t *ent );
+void SP_target_bpctrl( gentity_t *ent );
+void SP_target_class( gentity_t *ent );
+void SP_target_equipment( gentity_t *ent );
+void SP_target_power( gentity_t *ent );
+void SP_target_creep( gentity_t *ent );
+// ==Troy== AMP definition of the targets END
 
+
 void SP_light( gentity_t *self );
 void SP_info_null( gentity_t *self );
 void SP_info_notnull( gentity_t *self );
@@ -253,7 +294,12 @@
   { "func_train",               SP_func_train },
   { "func_group",               SP_info_null },
   { "func_timer",               SP_func_timer },      // rename trigger_timer?
+// ==Troy== AMP definition of the targets BEGIN
+  { "func_destructable",        SP_func_destructable },
+  { "func_spawn",               SP_func_spawn },
+// ==Troy== AMP definition of the targets END
 
+
   // Triggers are brush objects that cause an effect when contacted
   // by a living player, usually involving firing targets.
   // While almost everything could be done with
@@ -289,6 +335,23 @@
   { "target_alien_win",         SP_target_alien_win },
   { "target_human_win",         SP_target_human_win },
   { "target_hurt",              SP_target_hurt },
+// ==Troy== AMP definition of the targets BEGIN
+  { "target_and",               SP_target_and },
+  { "target_or",                SP_target_or },
+  { "target_xor",               SP_target_xor },
+  { "target_count",             SP_target_count },
+  { "target_stgctrl",           SP_target_stgctrl },
+  { "target_if",                SP_target_if },
+  { "target_fund",              SP_target_fund },
+  { "target_force_weapon",      SP_target_force_weapon },
+  { "target_force_class",       SP_target_force_class },
+  { "target_force_win",         SP_target_force_win },
+  { "target_bpctrl",            SP_target_bpctrl },
+  { "target_class",             SP_target_class },
+  { "target_equipment",         SP_target_equipment },
+  { "target_power",             SP_target_power },
+  { "target_creep",             SP_target_creep },  
+// ==Troy== AMP definition of the targets END
 
   { "light",                    SP_light },
   { "path_corner",              SP_path_corner },
@@ -462,7 +525,7 @@
           break;
       }
 
-      return;
+     // ==Troy== AMP return removed, we can still 1 key set to multiple vars
     }
   }
 }
Index: src/game/g_local.h
===================================================================
--- src/game/g_local.h	(revision 92)
+++ src/game/g_local.h	(working copy)
@@ -52,6 +52,14 @@
 #define FL_NO_BOTS        0x00002000  // spawn point not for bot use
 #define FL_NO_HUMANS      0x00004000  // spawn point just for bots
 #define FL_FORCE_GESTURE  0x00008000  // spawn point just for bots
+//AMP definitions
+#define RESET_BIT         0x80000000
+#define RESET_AFTER_USE   0x40000000
+#define AMP_TRIGGER       0x20000000
+#define LOCKSTAGE_BIT     0x80000
+#define TEAM_BIT          0x40000
+#define SIGN_BIT          0x20000
+#define VALUE_MASK        0x1FFFF
 
 typedef struct
 {
@@ -144,8 +152,10 @@
   int               timestamp;      // body queue sinking, etc
 
   float             angle;          // set in editor, -1 = up, -2 = down
-  char              *target;
+  char              *target; 
   char              *targetname;
+  char              *multitarget[ MAX_TARGETS ]; 
+  char              *multitargetname[ MAX_TARGETNAMES ]; //==Troy== AMP
   char              *team;
   char              *targetShaderName;
   char              *targetShaderNewName;
@@ -254,11 +264,26 @@
   int               suicideTime;                    // when the client will suicide
 
   int               lastDamageTime;
-  
+
   int               bdnumb;     // buildlog entry ID
-  
+
   // For nobuild!
-  noBuild_t	    noBuild;
+  noBuild_t         noBuild;
+
+  // ==Troy== AMP reserved variables BEGIN
+  int               hurt;
+  char              *Cvar_Val;
+  char              *sign;
+  char              *inventory; 
+  int               AMPintVAR[ 4 ];
+  qboolean          TrigOnlyRise;
+  int               TargetGate;
+  int               ResetValue;
+  int               Charge;
+  int               GateState;
+  qboolean          MasterPower;
+  int               PowerRadius;
+  // ==Troy== AMP reserved variables END
 };
 
 typedef enum
@@ -1296,6 +1321,13 @@
 
 #define FOFS(x) ((int)&(((gentity_t *)0)->x))
 
+
+//==Troy== AMP cvars add
+extern  vmCvar_t  g_AMPStageLock;
+extern  vmCvar_t  g_AMPDebug;
+//==Troy== AMP cvars END
+
+
 extern  vmCvar_t  g_dedicated;
 extern  vmCvar_t  g_cheats;
 extern  vmCvar_t  g_maxclients;     // allow this many total, including spectators
Index: src/game/g_combat.c
===================================================================
--- src/game/g_combat.c	(revision 92)
+++ src/game/g_combat.c	(working copy)
@@ -435,18 +435,20 @@
   // if players did more than DAMAGE_FRACTION_FOR_KILL increment the stage counters
   if( !OnSameTeam( self, attacker ) && totalDamage >= ( self->client->ps.stats[ STAT_MAX_HEALTH ] * DAMAGE_FRACTION_FOR_KILL ) )
   {
-    if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) 
+    if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && ( g_AMPStageLock.integer == 0 ) )
     {
-      trap_Cvar_Set( "g_alienKills", va( "%d", g_alienKills.integer + 1 ) );
+      if( g_AMPStageLock.integer == 0 )
+        trap_Cvar_Set( "g_alienKills", va( "%d", g_alienKills.integer + 1 ) );
       if( g_alienStage.integer < 2 )
       {
         self->client->pers.statscounters.feeds++;
         level.humanStatsCounters.feeds++;
       }
     }
-    else if( self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    else if( self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS && ( g_AMPStageLock.integer == 0 )  )
     {
-      trap_Cvar_Set( "g_humanKills", va( "%d", g_humanKills.integer + 1 ) );
+      if( g_AMPStageLock.integer == 0 )
+        trap_Cvar_Set( "g_humanKills", va( "%d", g_humanKills.integer + 1 ) );
       if( g_humanStage.integer < 2 )
       {
         self->client->pers.statscounters.feeds++;
@@ -1157,12 +1159,14 @@
          vec3_t dir, vec3_t point, int damage, int dflags, int mod )
 {
   gclient_t *client;
+  int weapon = WP_NONE, upgrade = UP_NONE, class = PCL_NONE, k;
   int     take;
   int     save;
   int     asave = 0;
   int     knockback;
   float damagemodifier=0.0;
   int takeNoOverkill;
+  qboolean inflictDamage = qtrue;
 
   if( !targ->takedamage )
     return;
@@ -1172,6 +1176,21 @@
   if( level.intermissionQueued )
     return;
 
+  if( inflictor )
+  {
+    upgrade = BG_FindUpgradeNumForName(inflictor->classname);
+    weapon = BG_FindWeaponNumForName(inflictor->classname);
+  }
+
+  if( !inflictor && attacker->client)
+  {
+    if(attacker->client->pers.teamSelection == PTE_HUMANS)
+      weapon = BG_FindWeaponNumForName(inflictor->classname);
+
+    if(attacker->client->pers.teamSelection == PTE_ALIENS)
+      class = attacker->client->ps.stats[ STAT_PCLASS ];  
+  }
+
   if( !inflictor )
     inflictor = &g_entities[ ENTITYNUM_WORLD ];
 
@@ -1184,9 +1203,27 @@
   // shootable doors / buttons don't actually have any health
   if( targ->s.eType == ET_MOVER )
   {
-    if( targ->use && ( targ->moverState == MOVER_POS1 ||
-                       targ->moverState == ROTATOR_POS1 ) )
-      targ->use( targ, inflictor, attacker );
+    for( k = 0; ; k++)
+    {
+      if(!targ->wTriggers[k] && !targ->uTriggers[k] && !targ->cTriggers[k]) break;
+      if(targ->wTriggers[k] && (targ->wTriggers[k] & weapon )) { inflictDamage = qfalse; break;}
+      if(targ->uTriggers[k] && (targ->uTriggers[k] & upgrade)) { inflictDamage = qfalse; break;}
+      if(targ->cTriggers[k] && (targ->cTriggers[k] & class  )) { inflictDamage = qfalse; break;}
+    }
+    if(inflictDamage)
+    {
+      if (targ->health - damage <= 0)
+      {
+        targ->health = 0;
+        if( targ->use && ( targ->moverState == MOVER_POS1 ||
+            targ->moverState == ROTATOR_POS1 ) )
+          targ->use( targ, inflictor, attacker );
+      }
+      else
+      {
+        targ->health -= damage;
+      }
+    }
 
     return;
   }
Index: src/game/g_buildable.c
===================================================================
--- src/game/g_buildable.c	(revision 92)
+++ src/game/g_buildable.c	(working copy)
@@ -194,21 +194,33 @@
   //iterate through entities
   for ( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++ )
   {
-    if( ent->s.eType != ET_BUILDABLE )
+  qboolean extPower = qfalse;
+  qboolean extRC = qfalse;
+  int extRad = 0;
+    if( ent->s.eType != ET_BUILDABLE && strcmp(ent->classname, "target_power"))
       continue;
-
+	if( !strcmp(ent->classname, "target_power") )
+	{
+		extPower = qtrue;
+		extRC = ent->MasterPower;
+		extRad = ent->PowerRadius;
+	}
+	
     //if entity is a power item calculate the distance to it
-    if( ( ent->s.modelindex == BA_H_REACTOR || ent->s.modelindex == BA_H_REPEATER ) &&
-        ent->spawned )
+    if( extPower || (( ent->s.modelindex == BA_H_REACTOR || ent->s.modelindex == BA_H_REPEATER ) &&
+        ent->spawned) )
     {
       VectorSubtract( self->s.origin, ent->s.origin, temp_v );
       distance = VectorLength( temp_v );
 
-      if( distance < minDistance && ent->powered &&
-          ( ( ent->s.modelindex == BA_H_REACTOR &&
-            distance <= REACTOR_BASESIZE ) ||
-          ( ent->s.modelindex == BA_H_REPEATER &&
-            distance <= REPEATER_BASESIZE ) ) ) {
+      if( distance < minDistance 									 && 
+		  (( ent->powered && ((extRC && distance <= extRad) 		 || 
+		  (extPower && level.reactorPresent && distance <= extRad))) || 
+		  (ent->powered 											 &&
+          ( ( ent->s.modelindex == BA_H_REACTOR 					 &&
+            distance <= REACTOR_BASESIZE ) 							 ||
+          ( ent->s.modelindex == BA_H_REPEATER 						 &&
+            distance <= REPEATER_BASESIZE ) ))) ) {
 
           closestPower = ent;
           minDistance = distance;
@@ -392,7 +404,9 @@
   int       distance = 0;
   int       minDistance = 10000;
   vec3_t    temp_v;
-
+  qboolean extPower = qfalse;
+  qboolean extRC = qfalse;
+  int extRad = 0;
   //don't check for creep if flying through the air
   if( self->s.groundEntityNum == -1 )
     return qtrue;
@@ -402,23 +416,37 @@
   {
     for ( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++ )
     {
-      if( ent->s.eType != ET_BUILDABLE )
-        continue;
+	  extPower = qfalse;
+	  extRC = qfalse;
+	  extRad = 0;
+	  if( !(ent->s.eType == ET_BUILDABLE || (ent->powered && !strcmp(ent->classname, "target_creep"))))
+	    continue;
+	  if( !strcmp(ent->classname, "target_creep") )
+	  {
+		extPower = qtrue;
+		extRC = ent->MasterPower;
+		extRad = ent->PowerRadius;
+	  }
 
-      if( ( ent->s.modelindex == BA_A_SPAWN || ent->s.modelindex == BA_A_OVERMIND ) &&
-          ent->spawned )
+
+      if( extPower || (( ent->s.modelindex == BA_A_SPAWN || ent->s.modelindex == BA_A_OVERMIND ) &&
+          ent->spawned) )
       {
         VectorSubtract( self->s.origin, ent->s.origin, temp_v );
         distance = VectorLength( temp_v );
         if( distance < minDistance )
         {
+			if ( extPower && (distance <= extRad)) {
+				self->parentNode = ent;
+				return qtrue;
+			}
           closestSpawn = ent;
           minDistance = distance;
         }
       }
     }
 
-    if( minDistance <= CREEP_BASESIZE )
+    if( minDistance <= CREEP_BASESIZE  )
     {
       self->parentNode = closestSpawn;
       return qtrue;
@@ -3176,6 +3204,7 @@
   int               buildPoints;
   gentity_t	    *tmp;
   itemBuildError_t  tempReason;
+  gentity_t         *traceEnt;
 
   // Stop all buildables from interacting with traces
   G_SetBuildableLinkState( qfalse );
@@ -3183,6 +3212,7 @@
   BG_FindBBoxForBuildable( buildable, mins, maxs );
 
   BG_PositionBuildableRelativeToPlayer( ps, mins, maxs, trap_Trace, entity_origin, angles, &tr1 );
+  traceEnt = &g_entities[ tr1.entityNum ];
 
   trap_Trace( &tr2, entity_origin, mins, maxs, entity_origin, ent->s.number, MASK_PLAYERSOLID );
   trap_Trace( &tr3, ps->origin, NULL, NULL, entity_origin, ent->s.number, MASK_PLAYERSOLID );
@@ -3197,7 +3227,7 @@
   if( !( normal[ 2 ] >= minNormal || ( invert && normal[ 2 ] <= -minNormal ) ) )
     reason = IBE_NORMAL;
 
-  if( tr1.entityNum != ENTITYNUM_WORLD )
+  if( !(tr1.entityNum == ENTITYNUM_WORLD || ( traceEnt && (!strcmp(traceEnt->classname, "func_destructable") || !strcmp(traceEnt->classname, "func_spawn")))) )
     reason = IBE_NORMAL;
 
   contents = trap_PointContents( entity_origin, -1 );
@@ -4278,6 +4308,7 @@
 */
 void G_SpawnRevertedBuildable( buildHistory_t *bh, qboolean mark )
 {
+/*
   vec3_t mins, maxs;
   int i, j, blockCount, blockers[ MAX_GENTITIES ];
   gentity_t *targ, *built, *toRecontent[ MAX_GENTITIES ];
@@ -4308,6 +4339,8 @@
   }
   for( i = 0; i < j; i++ )
     toRecontent[ i ]->r.contents = CONTENTS_BODY;
+	*/
+	return;
 }
 
 /*
Index: src/game/g_main.c
===================================================================
--- src/game/g_main.c	(revision 92)
+++ src/game/g_main.c	(working copy)
@@ -23,7 +23,8 @@
 
 #include "g_local.h"
 
-#define QVM_NAME       "Slackers QVM" " (Lakitu7 5.5)"
+#define QVM_NAME       "Slackers QVM" QVM_MODNAME " (Lakitu7 5.5)"
+#define QVM_MODNAME    " (AMP 0.1)"
 #define QVM_VERSIONNUM      "1.1"
 
 level_locals_t  level;
@@ -42,6 +43,11 @@
 gentity_t   g_entities[ MAX_GENTITIES ];
 gclient_t   g_clients[ MAX_CLIENTS ];
 
+
+//==Troy== AMP cvars add
+vmCvar_t  g_AMPStageLock;
+vmCvar_t  g_AMPDebug;
+//==Troy== AMP cvars END
 vmCvar_t  g_fraglimit;
 vmCvar_t  g_timelimit;
 vmCvar_t  g_suddenDeathTime;
@@ -237,6 +243,7 @@
 {
   // don't override the cheat state set by the system
   { &g_cheats, "sv_cheats", "", 0, 0, qfalse },
+  { &g_AMPDebug, "sv_AMPDebug", "", 0, 0, qfalse },
 
   // noset vars
   { NULL, "gamename", GAME_VERSION , CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
@@ -270,6 +277,10 @@
   { &g_devmapNoGod, "g_devmapNoGod", "0", CVAR_ARCHIVE, 0, qtrue  },
   { &g_devmapNoStructDmg, "g_devmapNoStructDmg", "0", CVAR_ARCHIVE, 0, qtrue  },
 
+  //==Troy== AMP cvars add
+  { &g_AMPStageLock, "g_AMPStageLock", "0", CVAR_ARCHIVE, 0, qtrue  },
+  //==Troy== AMP cvars END
+
   { &g_slapKnockback, "g_slapKnockback", "200", CVAR_ARCHIVE, 0, qfalse},
   { &g_slapDamage, "g_slapDamage", "0", CVAR_ARCHIVE, 0, qfalse},
 
Index: src/game/g_target.c
===================================================================
--- src/game/g_target.c	(revision 92)
+++ src/game/g_target.c	(working copy)
@@ -43,6 +43,7 @@
 
 void SP_target_delay( gentity_t *ent )
 {
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   // check delay for backwards compatability
   if( !G_SpawnFloat( "delay", "0", &ent->wait ) )
     G_SpawnFloat( "wait", "1", &ent->wait );
@@ -71,6 +72,7 @@
 
 void SP_target_score( gentity_t *ent )
 {
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( !ent->count )
     ent->count = 1;
 
@@ -107,6 +109,7 @@
 
 void SP_target_print( gentity_t *ent )
 {
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   ent->use = Use_Target_Print;
 }
 
@@ -131,9 +134,15 @@
   if( ent->spawnflags & 3 )
   {  // looping sound toggles
     if( ent->s.loopSound )
+    {
       ent->s.loopSound = 0; // turn it off
+      G_FreeEntity(ent);
+    }
     else
+    {
       ent->s.loopSound = ent->noise_index;  // start it
+      trap_LinkEntity(ent);
+    }
   }
   else
   {
@@ -151,7 +160,7 @@
 {
   char  buffer[ MAX_QPATH ];
   char  *s;
-
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnFloat( "wait", "0", &ent->wait );
   G_SpawnFloat( "random", "0", &ent->random );
 
@@ -218,6 +227,7 @@
 */
 void SP_target_teleporter( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( !self->targetname )
     G_Printf( "untargeted %s at %s\n", self->classname, vtos( self->s.origin ) );
 
@@ -258,6 +268,8 @@
 
 void SP_target_relay( gentity_t *self )
 {
+
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   self->use = target_relay_use;
 }
 
@@ -277,6 +289,7 @@
 
 void SP_target_kill( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   self->use = target_kill_use;
 }
 
@@ -285,6 +298,7 @@
 */
 void SP_target_position( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SetOrigin( self, self->s.origin );
 }
 
@@ -327,6 +341,7 @@
 */
 void SP_target_location( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   self->think = target_location_linkup;
   self->nextthink = level.time + 200;  // Let them all spawn first
 
@@ -388,6 +403,7 @@
 */
 void SP_target_rumble( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( !self->targetname )
   {
     G_Printf( S_COLOR_YELLOW "WARNING: untargeted %s at %s\n", self->classname,
@@ -421,6 +437,7 @@
 */
 void SP_target_alien_win( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   self->use = target_alien_win_use;
 }
 
@@ -441,6 +458,7 @@
 */
 void SP_target_human_win( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   self->use = target_human_win_use;
 }
 
@@ -465,6 +483,7 @@
 */
 void SP_target_hurt( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( !self->targetname )
   {
     G_Printf( S_COLOR_YELLOW "WARNING: untargeted %s at %s\n", self->classname,
@@ -476,3 +495,879 @@
 
   self->use = target_hurt_use;
 }
+
+//=============================
+// ==Troy== AMP targets BEGIN===
+//=============================
+
+/*
+bpctrl target
+*/
+
+void Use_Target_bpctrl( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  if (!other->TargetGate) return;
+  if ( other->TargetGate && (other->TargetGate & RESET_BIT))
+  {
+    if (other->TargetGate & TEAM_BIT)	g_humanBuildPoints.integer = 0;
+    if (!other->TargetGate & TEAM_BIT)	g_alienBuildPoints.integer = 0;
+  }
+
+  if (other->TargetGate & TEAM_BIT)
+  {
+    if (other->TargetGate & SIGN_BIT)
+      g_humanBuildPoints.integer -= (other->TargetGate & VALUE_MASK);
+    else
+      g_humanBuildPoints.integer += (other->TargetGate & VALUE_MASK);
+  }
+  else
+  {
+    if (other->TargetGate & SIGN_BIT)
+      g_alienBuildPoints.integer -= (other->TargetGate & VALUE_MASK);
+    else
+      g_alienBuildPoints.integer += (other->TargetGate & VALUE_MASK);
+  }
+
+  if (g_humanBuildPoints.integer < 0) 
+    g_humanBuildPoints.integer = 0;
+  if (g_humanBuildPoints.integer > 5000) 
+    g_humanBuildPoints.integer = 5000;
+
+
+  if (g_alienBuildPoints.integer < 0) 
+    g_alienBuildPoints.integer = 0;
+  if (g_alienBuildPoints.integer > 5000) 
+    g_alienBuildPoints.integer = 5000;
+}
+
+void SP_target_bpctrl( gentity_t *ent )
+{
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+
+  ent->use = Use_Target_bpctrl;
+}
+
+/*
+Force Win Target
+*/
+
+void Use_Target_force_win( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  if (ent->AMPintVAR[0] == 1)
+  {
+    level.lastWin = PTE_HUMANS;
+    trap_SendServerCommand( -1, "print \"Humans win\n\"");
+    trap_SetConfigstring( CS_WINNER, "Humans Win" );
+    LogExit( "Humans win." );
+    G_admin_maplog_result( "h" );
+  }
+  else
+  {
+    level.lastWin = PTE_ALIENS;
+    trap_SendServerCommand( -1, "print \"Aliens win\n\"");
+    trap_SetConfigstring( CS_WINNER, "Aliens Win" );
+    LogExit( "Aliens win." );
+    G_admin_maplog_result( "a" );
+  }
+}
+
+void SP_target_force_win( gentity_t *ent )
+{
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnInt( "team", "0", &ent->AMPintVAR[0] ); // 0 - aliens  1 - humans
+
+  ent->use = Use_Target_force_win;
+}
+
+/*
+Force player to class.
+*/
+
+// Basically a copy-paste from the g_cmds.c. Don't want to make the  G_RoomForClassCgange globally available, hence forced to use as a new function here.
+static qboolean G_RoomForClassChange_target( gentity_t *ent, pClass_t class,
+                                             vec3_t newOrigin )
+{
+  vec3_t    fromMins, fromMaxs;
+  vec3_t    toMins, toMaxs;
+  vec3_t    temp;
+  trace_t   tr;
+  float     nudgeHeight;
+  float     maxHorizGrowth;
+  pClass_t  oldClass = ent->client->ps.stats[ STAT_PCLASS ];
+
+  BG_FindBBoxForClass( oldClass, fromMins, fromMaxs, NULL, NULL, NULL );
+  BG_FindBBoxForClass( class, toMins, toMaxs, NULL, NULL, NULL );
+
+  VectorCopy( ent->r.currentOrigin, newOrigin );
+
+  // find max x/y diff
+  maxHorizGrowth = toMaxs[ 0 ] - fromMaxs[ 0 ];
+  if( toMaxs[ 1 ] - fromMaxs[ 1 ] > maxHorizGrowth )
+    maxHorizGrowth = toMaxs[ 1 ] - fromMaxs[ 1 ];
+  if( toMins[ 0 ] - fromMins[ 0 ] > -maxHorizGrowth )
+    maxHorizGrowth = -( toMins[ 0 ] - fromMins[ 0 ] );
+  if( toMins[ 1 ] - fromMins[ 1 ] > -maxHorizGrowth )
+    maxHorizGrowth = -( toMins[ 1 ] - fromMins[ 1 ] );
+
+  if( maxHorizGrowth > 0.0f )
+  {
+    // test by moving the player up the max required on a 60 degree slope
+    nudgeHeight = maxHorizGrowth * 2.0f;
+  }
+  else
+  {
+    // player is shrinking, so there's no need to nudge them upwards
+    nudgeHeight = 0.0f;
+  }
+
+  // find what the new origin would be on a level surface
+  newOrigin[ 2 ] += fabs( toMins[ 2 ] ) - fabs( fromMins[ 2 ] );
+
+  //compute a place up in the air to start the real trace
+  VectorCopy( newOrigin, temp );
+  temp[ 2 ] += nudgeHeight;
+  trap_Trace( &tr, newOrigin, toMins, toMaxs, temp, ent->s.number, MASK_PLAYERSOLID );
+
+  //trace down to the ground so that we can evolve on slopes
+  VectorCopy( newOrigin, temp );
+  temp[ 2 ] += ( nudgeHeight * tr.fraction );
+  trap_Trace( &tr, temp, toMins, toMaxs, newOrigin, ent->s.number, MASK_PLAYERSOLID );
+  VectorCopy( tr.endpos, newOrigin );
+
+  //make REALLY sure
+  trap_Trace( &tr, newOrigin, toMins, toMaxs, newOrigin,
+               ent->s.number, MASK_PLAYERSOLID );
+
+  //check there is room to evolve
+  if( !tr.startsolid && tr.fraction == 1.0f )
+    return qtrue;
+  else
+    return qfalse;
+}
+
+void Use_Target_force_class( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  vec3_t infestOrigin;
+  int clientNum, i;
+
+  i = BG_FindClassNumForName( ent->inventory );
+
+  if( activator
+       &&    activator->client
+       &&    activator->client->ps.stats[ STAT_PTEAM ] ==  PTE_ALIENS
+       && !( activator->client->ps.stats[ STAT_STATE ] & SS_INFESTING )
+       && !( activator->client->ps.stats[ STAT_STATE ] &  SS_HOVELING )
+       && (G_RoomForClassChange_target( activator, i, infestOrigin ) )
+       &&  ( activator->client->ps.stats[ STAT_PCLASS ] != i ) )
+  {
+
+    if( i == PCL_NONE )
+    {
+      trap_SendServerCommand( -1 , "print \"Unknown class (target_force_class)\n\"" );
+      return;
+    }
+    clientNum = activator->client - level.clients;
+    if(activator->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING) activator->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBING;
+    if(activator->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING) activator->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBINGCEILING;
+
+    activator->client->pers.evolveHealthFraction = (float)activator->client->ps.stats[ STAT_HEALTH ] /
+        (float)BG_FindHealthForClass( activator->client->pers.classSelection );
+
+    if( activator->client->pers.evolveHealthFraction < 0.0f )
+      activator->client->pers.evolveHealthFraction = 0.0f;
+    else if( activator->client->pers.evolveHealthFraction > 1.0f )
+      activator->client->pers.evolveHealthFraction = 1.0f;
+
+
+    activator->client->pers.classSelection = i;
+    activator->client->ps.stats[ STAT_PCLASS ] = i;
+    ClientUserinfoChanged( clientNum, qfalse );
+
+    VectorCopy( infestOrigin, activator->s.pos.trBase );
+    ClientSpawn( activator, activator, activator->s.pos.trBase, activator->s.apos.trBase );
+
+    ent->activator = activator;
+    G_UseTargets( ent, ent->activator );		
+
+  }
+  else return;
+}
+
+void SP_target_force_class( gentity_t *ent )
+{
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+
+  ent->use = Use_Target_force_class;
+}
+
+/*
+Force player to use a weapon.
+*/
+
+void Use_Target_force_weapon( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  int i, j;
+  int    maxAmmo, maxClips;
+  qboolean change = qfalse;
+
+  if (activator && activator->client && activator->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS)
+  {
+    if ( other->TargetGate && (other->TargetGate & RESET_BIT)) 
+    {
+      activator->client->ps.stats[ STAT_WEAPONS ] = 0;
+      activator->client->ps.stats[ STAT_WEAPONS2 ] = 0;
+      activator->client->ps.stats[ STAT_SLOTS ] = 0;
+      G_ForceWeaponChange( activator, WP_NONE );
+    }
+
+    if ( other->TargetGate && (other->TargetGate & SIGN_BIT)) 
+    {
+      for( i = 0; ent->wTriggers[ i ] != WP_NONE; i++ )
+      {
+        if( BG_InventoryContainsWeapon( ent->wTriggers[ i ], activator->client->ps.stats ) )
+        {
+          BG_RemoveWeaponFromInventory( ent->wTriggers[ i ], activator->client->ps.stats );
+          if( ent->wTriggers[ i ] == ent->client->ps.weapon )
+            G_ForceWeaponChange( activator, WP_NONE );
+        }
+      }
+
+      for( i = 0; ent->uTriggers[ i ] != UP_NONE; i++ )
+      {
+        if( BG_InventoryContainsUpgrade( ent->uTriggers[ i ], activator->client->ps.stats ) )
+          BG_RemoveUpgradeFromInventory( ent->uTriggers[ i ], activator->client->ps.stats );
+      }
+    }
+
+    if ( !other->TargetGate || !(other->TargetGate & SIGN_BIT)) 
+    {
+      for( i = 0; ent->wTriggers[ i ] != WP_NONE; i++ )
+      {
+        if( BG_InventoryContainsWeapon( ent->wTriggers[ i ], activator->client->ps.stats ) ) continue;
+        else
+        {
+          for( j = WP_NONE + 1; j < WP_NUM_WEAPONS; j++ )
+          {
+            if( j != WP_BLASTER && BG_InventoryContainsWeapon( j, activator->client->ps.stats ) )
+            {
+              BG_RemoveWeaponFromInventory( j, activator->client->ps.stats );		
+              if( j == ent->client->ps.weapon )
+                G_ForceWeaponChange( activator, WP_NONE );
+            }
+          }
+
+          BG_AddWeaponToInventory( ent->wTriggers[ i ], activator->client->ps.stats );	
+          BG_FindAmmoForWeapon( ent->wTriggers[ i ], &maxAmmo, &maxClips );
+
+          if( BG_FindUsesEnergyForWeapon( ent->wTriggers[ i ] ) &&
+              BG_InventoryContainsUpgrade( UP_BATTPACK, activator->client->ps.stats ) )
+            maxAmmo = (int)( (float)maxAmmo * BATTPACK_MODIFIER );
+
+          BG_PackAmmoArray( ent->wTriggers[ i ], activator->client->ps.ammo, activator->client->ps.powerups, maxAmmo, maxClips );
+          G_ForceWeaponChange( activator, ent->wTriggers[ i ] );		
+          change = qtrue;
+        }
+      }
+
+      for( i = 0; ent->uTriggers[ i ] != UP_NONE; i++ )
+      {
+        if( BG_InventoryContainsUpgrade( ent->uTriggers[ i ], activator->client->ps.stats ) ) continue;
+
+        if( ent->uTriggers[ i ] == UP_AMMO )
+        {
+          if (BG_FindUsesEnergyForWeapon( activator->client->ps.weapon ))
+            G_GiveClientMaxAmmo( activator, qtrue );
+          else
+            G_GiveClientMaxAmmo( activator, qfalse );
+          continue;
+        }
+
+        if ( ent->uTriggers[ i ] == UP_BATTPACK || ent->uTriggers[ i ] == UP_JETPACK || ent->uTriggers[ i ] == UP_LIGHTARMOUR || ent->uTriggers[ i ] == UP_HELMET )
+          BG_RemoveUpgradeFromInventory( UP_BATTLESUIT, activator->client->ps.stats );
+        if ( ent->uTriggers[ i ] == UP_BATTLESUIT)
+        {
+          BG_RemoveUpgradeFromInventory( UP_BATTPACK, activator->client->ps.stats );
+          BG_RemoveUpgradeFromInventory( UP_JETPACK, activator->client->ps.stats );
+          BG_RemoveUpgradeFromInventory( UP_LIGHTARMOUR, activator->client->ps.stats );
+          BG_RemoveUpgradeFromInventory( UP_HELMET, activator->client->ps.stats );
+        }
+
+        if ( ent->uTriggers[ i ] == UP_BATTPACK)
+          BG_RemoveUpgradeFromInventory( UP_JETPACK, activator->client->ps.stats );
+        if ( ent->uTriggers[ i ] == UP_JETPACK)
+          BG_RemoveUpgradeFromInventory( UP_BATTPACK, activator->client->ps.stats );
+
+        BG_AddUpgradeToInventory( ent->uTriggers[ i ], activator->client->ps.stats );
+        if( ent->uTriggers[ i ] == UP_BATTPACK )
+        {
+          G_GiveClientMaxAmmo( activator, qtrue );
+        }
+        change = qtrue;
+      }
+    }
+    if (change)
+    {
+      ClientUserinfoChanged( activator->client->ps.clientNum, qfalse );
+      ent->activator = activator;
+      G_UseTargets( ent, ent->activator );
+    }
+  }
+
+}
+
+void SP_target_force_weapon( gentity_t *ent )
+{
+  char *buffer;
+  //G_SpawnString( "inventory", "NULL", &ent->Cvar_Val );
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+
+  G_SpawnString( "inventory", "", &buffer );
+
+  BG_ParseCSVEquipmentList( buffer, ent->wTriggers, WP_NUM_WEAPONS,
+                            ent->uTriggers, UP_NUM_UPGRADES );
+
+  ent->use = Use_Target_force_weapon;
+}
+
+/*
+Give Funds Target
+*/
+
+void Use_Target_fund( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+
+  if (activator && activator->client)
+  {
+    if (activator->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS)
+    {
+      G_AddCreditToClient(activator->client, ent->AMPintVAR[0] , qtrue);
+      ent->activator = activator;
+      G_UseTargets( ent, ent->activator );
+    }
+    if (activator->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS)
+    {
+      G_AddCreditToClient(activator->client, ent->AMPintVAR[1] , qtrue);
+      ent->activator = activator;
+      G_UseTargets( ent, ent->activator );
+    }
+  }
+  else return;
+}
+
+void SP_target_fund( gentity_t *ent )
+{
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnInt( "hfund", "0", &ent->AMPintVAR[0] );
+  G_SpawnInt( "afund", "0", &ent->AMPintVAR[1] );
+
+  ent->use = Use_Target_fund;
+}
+
+//trap_SendServerCommand( -1,
+//  va( "print \"Value :  %i|  Actual : %i| Sign : |%s| Cvar : |%s|\n\"", ent->GateState, i, ent->sign, ent->Cvar_Val ) );
+
+/*
+If Target.
+*/
+
+void Use_Target_if( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  int i;
+  if (!strcmp(ent->Cvar_Val, "NULL")) return;
+  ent->activator = activator;
+
+  i = trap_Cvar_VariableIntegerValue(ent->Cvar_Val);
+
+
+  if (!strcmp(ent->sign, "=="))
+  {
+    if (i == ent->GateState) G_UseTargets( ent, ent->activator );
+    return;
+  }
+
+  if (!strcmp(ent->sign, "!="))
+  {
+    if (i != ent->GateState) G_UseTargets( ent, ent->activator );
+    return;
+  }
+
+  if (!strcmp(ent->sign, ">="))
+  {
+    if (i >= ent->GateState) G_UseTargets( ent, ent->activator );
+    return;
+  }
+
+  if (!strcmp(ent->sign, ">"))
+  {
+    if (i > ent->GateState) G_UseTargets( ent, ent->activator );
+    return;
+  }
+
+  if (!strcmp(ent->sign, "<="))
+  {
+    if (i <= ent->GateState) G_UseTargets( ent, ent->activator );
+    return;
+  }
+
+  if (!strcmp(ent->sign, "<"))
+  {
+    if (i < ent->GateState) G_UseTargets( ent, ent->activator );
+    return;
+  }
+
+}
+
+void SP_target_if( gentity_t *ent )
+{
+  G_SpawnInt( "value", "0", &ent->GateState );
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  ent->use = Use_Target_if;
+}
+
+/*
+StageControl Target
+*/
+
+
+//void Think_Target_stagecontrol( gentity_t *ent )
+//{
+//  G_UseTargets( ent, ent->activator );
+//}
+
+
+void Use_Target_stgctrl( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  ent->activator = activator;
+  if (!other->TargetGate) return;
+  if (other->TargetGate & RESET_BIT)
+  {
+    g_AMPStageLock.integer = 0;
+    if (other->TargetGate & TEAM_BIT)	g_humanStage.integer = 0;
+    if (!other->TargetGate & TEAM_BIT)	g_alienStage.integer = 0;
+  }
+
+  if (other->TargetGate & LOCKSTAGE_BIT) 
+    g_AMPStageLock.integer = 1; 
+  else 
+    g_AMPStageLock.integer = 0;
+
+  if (other->TargetGate & TEAM_BIT)
+  {	
+    if (other->TargetGate & SIGN_BIT)
+      g_humanStage.integer -= (other->TargetGate & VALUE_MASK);
+    else
+      g_humanStage.integer += (other->TargetGate & VALUE_MASK);
+  }
+  else 
+  {
+    if (other->TargetGate & SIGN_BIT)
+      g_alienStage.integer -= (other->TargetGate & VALUE_MASK);
+    else
+      g_alienStage.integer += (other->TargetGate & VALUE_MASK);
+  }
+
+  if (g_humanStage.integer < 0) 
+    g_humanStage.integer = 0;
+  if (g_humanStage.integer > g_humanMaxStage.integer) 
+    g_humanStage.integer = g_humanMaxStage.integer;
+
+
+  if (g_alienStage.integer < 0) 
+    g_alienStage.integer = 0;
+  if (g_alienStage.integer > g_alienMaxStage.integer) 
+    g_alienStage.integer = g_alienMaxStage.integer;
+}
+
+void SP_target_stgctrl( gentity_t *ent )
+{
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  ent->use = Use_Target_stgctrl;
+}
+
+/*
+Counter Target. Counts up and triggers when overflows.
+*/
+
+void Use_Target_count( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+
+  ent->activator = activator;
+
+  if ( (other->TargetGate && (other->TargetGate & RESET_BIT)) || (ent->Charge != 0 && ent->AMPintVAR[1] < level.time))
+  {
+    ent->AMPintVAR[0] = 0;
+    ent->AMPintVAR[1] = level.time + ent->Charge;
+  }
+
+  if ( !(other->TargetGate & SIGN_BIT) )
+  {
+    if (++ent->AMPintVAR[0] >= ent->ResetValue)
+    {
+      ent->AMPintVAR[0] = 0;
+      G_UseTargets( ent, ent->activator );
+    }
+  }
+  else if(--ent->AMPintVAR[0] < 0) ent->AMPintVAR[0] = 0;
+}
+
+void SP_target_count( gentity_t *ent )
+{
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnInt( "maxval", "1", &ent->ResetValue );
+  G_SpawnInt( "reset", "0", &ent->Charge );
+        //ent->ResetValue++;
+  if(ent->ResetValue <= 0) ent->ResetValue = 1;
+
+  ent->use = Use_Target_count;
+}
+
+/*
+AND Gate. max 8 inputs.
+*/
+
+//void Think_Target_AND( gentity_t *ent )
+//{
+//  G_UseTargets( ent, ent->activator );
+//}
+
+void Use_Target_AND( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  int j;
+  qboolean total;
+  if (!other->TargetGate) return;
+  total = ent->GateState == 0xFF;
+
+  ent->activator = activator;
+
+  j = ent->GateState;
+
+  if (other->TargetGate & RESET_BIT) 
+    ent->GateState = ent->ResetValue;
+  else	
+    ent->GateState ^= ((other->TargetGate) & 0xFF);
+
+  if ((total != (ent->GateState == 0xFF)) && !(ent->TrigOnlyRise && total))
+  {
+    if (other->TargetGate & RESET_AFTER_USE) ent->GateState = j;
+    G_UseTargets( ent, ent->activator );
+  }
+  else
+  {
+    if (other->TargetGate & RESET_AFTER_USE) ent->GateState = j;
+  }
+}
+
+void SP_target_and( gentity_t *ent )
+{
+  int i;
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnInt( "trigonlyrise", "0", &i );
+  if (i == 0)
+    ent->TrigOnlyRise = qfalse;
+  else
+    ent->TrigOnlyRise = qtrue;
+
+  G_SpawnInt("resetval","252", &ent->ResetValue);
+  ent->ResetValue &= 0xFF;
+
+  ent->GateState = ent->ResetValue;
+  ent->use = Use_Target_AND;
+}
+
+/*
+ORGate. max 8 inputs.
+*/
+
+//void Think_Target_AND( gentity_t *ent )
+//{
+//  G_UseTargets( ent, ent->activator );
+//}
+
+void Use_Target_OR( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  int j;
+  qboolean total;
+  if (!other->TargetGate) return;
+  total = ent->GateState || 0;
+  ent->activator = activator;
+
+  j = ent->GateState;
+
+  if ( other->TargetGate && (other->TargetGate & RESET_BIT)) 
+    ent->GateState = ent->ResetValue;
+  else	
+    ent->GateState ^= ((other->TargetGate) & 0xFF);
+
+  if ((total != (ent->GateState || 0)) && !(ent->TrigOnlyRise && total))
+  {
+    if (other->TargetGate & RESET_AFTER_USE) ent->GateState = j;
+    G_UseTargets( ent, ent->activator );
+  }
+  else
+  {
+    if (other->TargetGate & RESET_AFTER_USE) ent->GateState = j;
+  }
+}
+
+void SP_target_or( gentity_t *ent )
+{
+  int i;
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnInt( "trigonlyrise", "0", &i );
+  if (i == 0)
+    ent->TrigOnlyRise = qfalse;
+  else
+    ent->TrigOnlyRise = qtrue;
+
+  G_SpawnInt("resetval","0", &ent->ResetValue);
+  ent->ResetValue &= 0xFF;
+
+  ent->GateState = ent->ResetValue;
+
+
+  ent->use = Use_Target_OR;
+}
+
+/*
+XOR Gate. max 8 inputs.
+*/
+
+//void Think_Target_XOR( gentity_t *ent )
+//{
+//  G_UseTargets( ent, ent->activator );
+//}
+
+void Use_Target_XOR( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  int i, j;
+  qboolean total, test;
+  if (!other->TargetGate) return;
+  i = ent->GateState & 0xFF;
+  j = ent->GateState;
+  if(i == 0 || (i & (i - 1))) total = qfalse; else total = qtrue;
+
+  ent->activator = activator;
+
+  if ( other->TargetGate && (other->TargetGate & RESET_BIT)) 
+    ent->GateState = ent->ResetValue;
+  else	
+    ent->GateState ^= ((other->TargetGate) & 0xFF);
+
+  i = ent->GateState;
+  if(i == 0 || (i & (i - 1))) test = qfalse; else test = qtrue;
+
+  if ((total != test)  && !(ent->TrigOnlyRise && total))
+  {
+    if (other->TargetGate & RESET_AFTER_USE) ent->GateState = j;
+    G_UseTargets( ent, ent->activator );
+  }
+  else
+  {
+    if (other->TargetGate & RESET_AFTER_USE) ent->GateState = j;
+  }
+}
+
+void SP_target_xor( gentity_t *ent )
+{
+  int i;
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnInt( "trigonlyrise", "0", &i );
+  if (i == 0)
+    ent->TrigOnlyRise = qfalse;
+  else
+    ent->TrigOnlyRise = qtrue;
+
+  G_SpawnInt("resetval","254", &ent->ResetValue);
+  ent->ResetValue &= 0xFF;
+
+  ent->GateState = ent->ResetValue;
+
+
+  ent->use = Use_Target_XOR;
+}
+
+/*
+===============
+trigger_class_match
+===============
+*/
+qboolean target_class_match( gentity_t *self, gentity_t *activator )
+{
+  int i = 0;
+
+  //if there is no class list every class triggers (stupid case)
+  if( self->cTriggers[ i ] == PCL_NONE )
+    return qtrue;
+  else
+  {
+    //otherwise check against the list
+    for( i = 0; self->cTriggers[ i ] != PCL_NONE; i++ )
+    {
+      if( activator->client->ps.stats[ STAT_PCLASS ] == self->cTriggers[ i ] )
+        return qtrue;
+    }
+  }
+
+  return qfalse;
+}
+
+/*
+===============
+trigger_class_trigger
+===============
+*/
+void target_class_trigger( gentity_t *self, gentity_t *activator )
+{
+  //sanity check
+  if( !activator->client )
+    return;
+
+  if( activator->client->ps.stats[ STAT_PTEAM ] != PTE_ALIENS )
+    return;
+
+  self->activator = activator;
+
+  if( self->s.eFlags & EF_DEAD )
+  {
+    if( !target_class_match( self, activator ) )
+      G_UseTargets( self, activator );
+  }
+  else
+  {
+    if( target_class_match( self, activator ) )
+      G_UseTargets( self, activator );
+  }
+}
+
+/*
+===============
+trigger_class_touch
+===============
+*/
+void target_class_use( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  //only triggered by clients
+  if( !other->client )
+    return;
+
+  target_class_trigger( ent, other );
+}
+
+
+void SP_target_class( gentity_t *self )
+{
+  char *buffer;
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnString( "classes", "", &buffer );
+
+  BG_ParseCSVClassList( buffer, self->cTriggers, PCL_NUM_CLASSES );
+
+  // NEGATE
+  if( self->spawnflags & 2 )
+    self->s.eFlags |= EF_DEAD;
+	
+  self->use = target_class_use;
+}
+
+/*
+
+Target equipment
+
+*/
+
+qboolean target_equipment_match( gentity_t *self, gentity_t *activator )
+{
+  int i = 0;
+
+  //if there is no equipment list all equipment triggers (stupid case)
+  if( self->wTriggers[ i ] == WP_NONE && self->uTriggers[ i ] == UP_NONE )
+    return qtrue;
+  else
+  {
+    //otherwise check against the lists
+    for( i = 0; self->wTriggers[ i ] != WP_NONE; i++ )
+    {
+      if( BG_InventoryContainsWeapon( self->wTriggers[ i ], activator->client->ps.stats ) )
+        return qtrue;
+    }
+
+    for( i = 0; self->uTriggers[ i ] != UP_NONE; i++ )
+    {
+      if( BG_InventoryContainsUpgrade( self->uTriggers[ i ], activator->client->ps.stats ) )
+        return qtrue;
+    }
+  }
+
+  return qfalse;
+}
+
+
+void target_equipment_use( gentity_t *self, gentity_t *other, gentity_t *activator )
+{
+  //sanity check
+  if( !activator->client )
+    return;
+
+  if( activator->client->ps.stats[ STAT_PTEAM ] != PTE_HUMANS )
+    return;
+
+  self->activator = activator;
+
+  if( self->s.eFlags & EF_DEAD )
+  {
+    if( !target_equipment_match( self, activator ) )
+      G_UseTargets( self, activator );
+  }
+  else
+  {
+    if( target_equipment_match( self, activator ) )
+      G_UseTargets( self, activator );
+  }
+}
+
+void SP_target_equipment( gentity_t *self )
+{
+  char *buffer;
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnString( "equipment", "", &buffer );
+
+  BG_ParseCSVEquipmentList( buffer, self->wTriggers, WP_NUM_WEAPONS,
+      self->uTriggers, UP_NUM_UPGRADES );
+
+  // NEGATE
+  if( self->spawnflags & 2 )
+    self->s.eFlags |= EF_DEAD;
+	
+  self->use = target_equipment_use;
+}
+
+void Use_target_power( gentity_t *self, gentity_t *other, gentity_t *activator )
+{
+self->powered = !self->powered;
+}
+
+void SP_target_power( gentity_t *self )
+{
+  G_SpawnInt( "radius", "100", &self->PowerRadius );
+
+  if(self->spawnflags & 1) self->MasterPower = qtrue; else self->MasterPower = qfalse;
+  if(!(self->spawnflags & 2)) self->powered = qtrue; else self->powered = qfalse;
+  self->use = Use_target_power;
+}
+
+
+void Use_target_creep( gentity_t *self, gentity_t *other, gentity_t *activator )
+{
+  self->powered = !self->powered;
+}
+
+void SP_target_creep( gentity_t *self )
+{
+  G_SpawnInt( "radius", "100", &self->PowerRadius );
+
+  if(self->spawnflags & 1) self->MasterPower = qtrue; else self->MasterPower = qfalse;
+  if(!(self->spawnflags & 2)) self->powered = qtrue; else self->powered = qfalse;
+  self->use = Use_target_creep;
+}
+
+// ==Troy== AMP targets END
Index: src/game/g_mover.c
===================================================================
--- src/game/g_mover.c	(revision 92)
+++ src/game/g_mover.c	(working copy)
@@ -833,6 +833,11 @@
   else if( ent->moverState == MOVER_POS2 )
   {
     // if all the way up, just delay before coming down
+    // ==Troy== AMP  now we can trigger door down even if it is all the way up and planning to stay there
+    if( ent->targetname && other && !other->client && other->TargetGate && (other->TargetGate & AMP_TRIGGER) )  // we check if it was triggered by the trigger and not the player
+      MatchTeam( ent, MOVER_2TO1, level.time + 50 );
+    else
+    // ==Troy== AMP code ends here, delete between the comment lines to return to default state
     ent->nextthink = level.time + ent->wait;
   }
   else if( ent->moverState == MOVER_2TO1 )
@@ -883,6 +888,11 @@
   else if( ent->moverState == ROTATOR_POS2 )
   {
     // if all the way up, just delay before coming down
+    // ==Troy== AMP  now we can trigger door down even if it is all the way up and planning to stay there
+    if( ent->targetname && other && !other->client && other->TargetGate && (other->TargetGate & AMP_TRIGGER)) // we check if it was triggered by the trigger and not the player
+      MatchTeam( ent, ROTATOR_2TO1, level.time + 50 );
+    else
+    // ==Troy== AMP code ends here, delete between the comment lines to return to default state
     ent->nextthink = level.time + ent->wait;
   }
   else if( ent->moverState == ROTATOR_2TO1 )
@@ -1406,7 +1416,7 @@
   vec3_t  size;
   float   lip;
   char    *s;
-
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnString( "sound2to1", "sound/movers/doors/dr1_strt.wav", &s );
   ent->sound2to1 = G_SoundIndex( s );
   G_SpawnString( "sound1to2", "sound/movers/doors/dr1_strt.wav", &s );
@@ -1502,7 +1512,7 @@
 void SP_func_door_rotating( gentity_t *ent )
 {
   char    *s;
-
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnString( "sound2to1", "sound/movers/doors/dr1_strt.wav", &s );
   ent->sound2to1 = G_SoundIndex( s );
   G_SpawnString( "sound1to2", "sound/movers/doors/dr1_strt.wav", &s );
@@ -1620,7 +1630,7 @@
   qboolean  lightSet, colorSet;
   char      *sound;
   gentity_t *clipBrush;
-
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnString( "sound2to1", "sound/movers/doors/dr1_strt.wav", &s );
   ent->sound2to1 = G_SoundIndex( s );
   G_SpawnString( "sound1to2", "sound/movers/doors/dr1_strt.wav", &s );
@@ -1849,7 +1859,7 @@
 {
   float lip, height;
   char  *s;
-
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnString( "sound2to1", "sound/movers/plats/pt1_strt.wav", &s );
   ent->sound2to1 = G_SoundIndex( s );
   G_SpawnString( "sound1to2", "sound/movers/plats/pt1_strt.wav", &s );
@@ -1940,6 +1950,7 @@
   vec3_t  size;
   float   lip;
   char    *s;
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
 
   G_SpawnString( "sound1to2", "sound/movers/switches/button1.wav", &s );
   ent->sound1to2 = G_SoundIndex( s );
@@ -2195,14 +2206,21 @@
 "speed" speed to move to the next corner
 "wait" seconds to wait before behining move to next corner
 */
+void path_corner_use( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  G_UseTargets( ent, NULL );
+}
+
 void SP_path_corner( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( !self->targetname )
   {
     G_Printf( "path_corner with no targetname at %s\n", vtos( self->s.origin ) );
     G_FreeEntity( self );
     return;
   }
+  self->use = path_corner_use;
   // path corners don't need to be linked in
 }
 
@@ -2271,6 +2289,7 @@
 */
 void SP_func_train( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   VectorClear( self->s.angles );
 
   if( self->spawnflags & TRAIN_BLOCK_STOPS )
@@ -2318,6 +2337,7 @@
 */
 void SP_func_static( gentity_t *ent )
 {
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   trap_SetBrushModel( ent, ent->model );
   InitMover( ent );
   VectorCopy( ent->s.origin, ent->s.pos.trBase );
@@ -2347,6 +2367,7 @@
 */
 void SP_func_rotating( gentity_t *ent )
 {
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( !ent->speed )
     ent->speed = 100;
 
@@ -2397,7 +2418,7 @@
 {
   float   height;
   float   phase;
-
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnFloat( "speed", "4", &ent->speed );
   G_SpawnFloat( "height", "32", &height );
   G_SpawnInt( "dmg", "2", &ent->damage );
@@ -2448,7 +2469,7 @@
   float length;
   float phase;
   float speed;
-
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnFloat( "speed", "30", &speed );
   G_SpawnInt( "dmg", "2", &ent->damage );
   G_SpawnFloat( "phase", "0", &phase );
@@ -2477,3 +2498,162 @@
   ent->s.apos.trType = TR_SINE;
   ent->s.apos.trDelta[ 2 ] = speed;
 }
+
+//=============================
+// ==Troy== AMP targets BEGIN===
+//=============================
+
+/*
+Func_spawn. A something which appears when triggered.
+*/
+
+void Use_func_spawn_dummy()
+{
+  return;
+}
+
+void func_spawn_think( gentity_t *ent )
+{
+  ent->touch = 0;
+  ent->think = 0;
+}
+
+void Touch_func_spawn ( gentity_t *self, gentity_t *other, trace_t *trace  )
+{
+  if( !other->client && other->s.eType != ET_BUILDABLE) return;
+  G_Damage( other, self, self, NULL, NULL, 1024, DAMAGE_NO_PROTECTION, MOD_TRIGGER_HURT );
+}
+
+
+void Use_func_spawn( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  ent->activator = activator;
+  G_UseTargets( ent, ent->activator );
+
+  if( ent->r.linked )
+  {
+        //trap_SetBrushModel( ent, NULL );
+    trap_UnlinkEntity( ent );
+  }
+  else
+  {
+    trap_LinkEntity( ent );
+    if( !( ent->spawnflags & 2 ) )
+    {
+      ent->touch = Touch_func_spawn;
+      ent->think = func_spawn_think;
+      ent->nextthink = level.time + 200;
+    }
+  }
+
+}
+
+//  ent->use = Use_func_spawn_deployed;
+
+void SP_func_spawn( gentity_t *ent )
+{
+  char *s;
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnString( "model", "", &s);
+
+  VectorCopy( ent->s.origin, ent->pos1 );
+  ent->moverState = MOVER_POS1;
+  ent->r.svFlags = SVF_USE_CURRENT_ORIGIN;
+  ent->s.eType = ET_MOVER;
+  VectorCopy( ent->pos1, ent->r.currentOrigin );
+  ent->s.pos.trType = TR_STATIONARY;
+  VectorCopy( ent->pos1, ent->s.pos.trBase );
+
+  if (!s || !strstr( s, ".md3" ))
+    trap_SetBrushModel( ent, ent->model );
+  else
+  {
+    ent->s.modelindex = G_ModelIndex( s );
+    VectorCopy( ent->s.angles, ent->s.apos.trBase );
+  }
+
+  ent->use = Use_func_spawn;
+
+  if( ( ent->spawnflags & 1 ) )
+    trap_LinkEntity( ent );
+  else
+    trap_UnlinkEntity( ent );
+}
+
+/*
+Func_destructable. A dummy brush which can be destroyed. Triggers its target upon destruction.
+*/
+
+void Use_func_destructable( gentity_t *ent, gentity_t *other, gentity_t *activator )
+{
+  vec3_t  origin;
+  int     splashDamage, splashRadius;
+  if( ent->r.linked )
+  {
+    VectorCopy( ent->pos1, origin);
+    splashDamage = ent->splashDamage;
+    splashRadius = ent->splashRadius;
+
+    //trap_SetBrushModel( ent, NULL );
+    ent->activator = activator;
+    if(!other->target)
+      G_UseTargets( ent, ent->activator );
+    trap_UnlinkEntity( ent );
+
+    //G_FreeEntity(ent);
+    G_RadiusDamage( origin, ent, splashDamage,
+                    splashRadius, ent, MOD_TRIGGER_HURT);
+  }
+  else
+  {
+    ent->health = ent->ResetValue;
+    trap_LinkEntity( ent );
+    ent->touch = Touch_func_spawn;
+    ent->think = func_spawn_think;
+    ent->nextthink = level.time + 200;
+  }
+}
+
+void SP_func_destructable( gentity_t *ent )
+{
+  char *s;
+  vec3_t origin;
+  char *buffer;
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+  G_SpawnString( "equipment", "", &buffer );
+  BG_ParseCSVEquipmentList( buffer, ent->wTriggers, WP_NUM_WEAPONS,
+                            ent->uTriggers, UP_NUM_UPGRADES );
+  G_SpawnString( "classes", "", &buffer );
+  BG_ParseCSVClassList( buffer, ent->cTriggers, PCL_NUM_CLASSES );	  
+
+  G_SpawnInt( "damage", "0", &ent->splashDamage );
+  G_SpawnInt( "radius", "0", &ent->splashRadius );
+  G_SpawnInt( "health", "100", &ent->ResetValue ); 
+  G_SpawnString( "model", "", &s);
+  ent->health = ent->ResetValue;
+
+  if (!s || !strstr( s, ".md3" ))
+    trap_SetBrushModel( ent, ent->model );
+  else
+  {
+    ent->s.modelindex = G_ModelIndex( s );
+    VectorCopy( ent->s.angles, ent->s.apos.trBase );
+  }
+
+  VectorCopy( ent->s.origin, ent->pos1 );
+  ent->takedamage = qtrue;
+
+  ent->use = Use_func_destructable;
+  ent->moverState = MOVER_POS1;
+  ent->r.svFlags = SVF_USE_CURRENT_ORIGIN;
+  ent->s.eType = ET_MOVER;
+  VectorCopy( ent->pos1, ent->r.currentOrigin );
+
+  trap_LinkEntity( ent );
+
+  ent->s.pos.trType = TR_STATIONARY;
+  VectorCopy( ent->pos1, ent->s.pos.trBase );
+
+}
+
+// ==Troy== AMP targets END
Index: src/game/g_utils.c
===================================================================
--- src/game/g_utils.c	(revision 92)
+++ src/game/g_utils.c	(working copy)
@@ -24,6 +24,7 @@
 // g_utils.c -- misc utility functions for game module
 
 #include "g_local.h"
+//#include "g_random.c"
 
 typedef struct
 {
@@ -221,9 +222,9 @@
 gentity_t *G_PickTarget( char *targetname )
 {
   gentity_t *ent = NULL;
-  int       num_choices = 0;
+  int       num_choices = 0,rnd, k, seed;
   gentity_t *choice[ MAXCHOICES ];
-
+  
   if( !targetname )
   {
     G_Printf("G_PickTarget called with NULL targetname\n");
@@ -248,8 +249,13 @@
     G_Printf( "G_PickTarget: target %s not found\n", targetname );
     return NULL;
   }
+  //#define RAND_MAX2 0xFFFFFFFF
+  seed = rand() & 255;   // FIX ME AMP
+  k = abs((int)(Q_crandom( &seed )*(float)num_choices));
+  rnd = k;//(int)(   ((float)(((double)k)/( (double)(RAND_MAX2) + (double)(1) )))*(float)num_choices   );
+  if(g_AMPDebug.integer >= 1) G_LogPrintf(va("PickTarget : random = %i out of %i, seed = %i\n", rnd, num_choices, seed));
 
-  return choice[ rand( ) % num_choices ];
+  return choice[ rnd ];
 }
 
 
@@ -267,7 +273,9 @@
 void G_UseTargets( gentity_t *ent, gentity_t *activator )
 {
   gentity_t   *t;
+  int i = 0, j = 0;
 
+  
   if( !ent )
     return;
 
@@ -277,27 +285,41 @@
     AddRemap( ent->targetShaderName, ent->targetShaderNewName, f );
     trap_SetConfigstring( CS_SHADERSTATE, BuildShaderStateConfig( ) );
   }
+  
 
-  if( !ent->target )
-    return;
 
-  t = NULL;
-  while( ( t = G_Find( t, FOFS( targetname ), ent->target ) ) != NULL )
-  {
-    if( t == ent )
-      G_Printf( "WARNING: Entity used itself.\n" );
-    else
-    {
-      if( t->use )
-        t->use( t, ent, activator );
-    }
+  
+	for (i = 0; i < MAX_TARGETS; i++) //==Troy== AMP multiple target support
+	{
+		  if( !ent->multitarget[ i ] )
+		    continue;
+			
+		for (j = 0; j < MAX_TARGETNAMES; j++)
+		{
+			  t = NULL;
+			  while( ( t = G_Find( t, FOFS( multitargetname[ j ] ), ent->multitarget[ i ] ) ) != NULL )
+			  {
+				    //if( t == ent )
+				    //  G_Printf( "WARNING: Entity used itself.\n" );   //==Troy== AMP gates can use themselves
+				   // else
+				   // {
+				      if( t->use )
+					  {
+					    if(g_AMPDebug.integer >= 1 && !(!strcmp(t->classname, "path_corner") || !strcmp(ent->classname, "path_corner"))) G_LogPrintf(va("Begin: %i : %s triggering %i: %s, Match : %s, Trigger Gate : %i, Target input state before trigger : %i\n", ent - g_entities, ent->classname, t - g_entities, t->classname, ent->multitarget[ i ], ent->TargetGate, t->GateState));
+				        t->use( t, ent, activator );
+						//trap_SendServerCommand( -1, va("print \"Who : %s| What : %s|\"", ent->classname, t->multitargetname[ j ] ));
+						if(g_AMPDebug.integer >= 2) G_LogPrintf(va("Exit: %i : %s has triggered %i : %s, Match : %s, Trigger Gate : %i, After State : %i\n", ent - g_entities, ent->classname, t - g_entities, t->classname, ent->multitarget[ i ], ent->TargetGate, t->GateState));
+					  }
+				   // }
 
-    if( !ent->inuse )
-    {
-      G_Printf( "entity was removed while using targets\n" );
-      return;
-    }
-  }
+				    if( !ent->inuse )
+				    {
+				      G_Printf( "entity was removed while using targets\n" );
+				      return;
+				    }
+			  }
+		}
+	}
 }
 
 
Index: src/game/g_trigger.c
===================================================================
--- src/game/g_trigger.c	(revision 92)
+++ src/game/g_trigger.c	(working copy)
@@ -86,7 +86,7 @@
 
 void Touch_Multi( gentity_t *self, gentity_t *other, trace_t *trace )
 {
-  if( !other->client && other->s.eType != ET_BUILDABLE )
+  if( !(other->client && ((other->client->buttons & self->GateState) || (self->GateState == 4294967295 ))) && other->s.eType != ET_BUILDABLE )
     return;
 
   multi_trigger( self, other );
@@ -101,9 +101,11 @@
 */
 void SP_trigger_multiple( gentity_t *ent )
 {
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnFloat( "wait", "0.5", &ent->wait );
   G_SpawnFloat( "random", "0", &ent->random );
-
+  
+  G_SpawnInt( "buttonmask", "4294967295", &ent->GateState ); //==Troy== AMP Player button pressed mask
   if( ent->random >= ent->wait && ent->wait >= 0 )
   {
     ent->random = ent->wait - FRAMETIME;
@@ -138,6 +140,8 @@
 */
 void SP_trigger_always( gentity_t *ent )
 {
+  G_SpawnInt( "gate", "255", &ent->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+
   // we must have some delay to make sure our use targets are present
   ent->nextthink = level.time + 300;
   ent->think = trigger_always_think;
@@ -212,6 +216,7 @@
 */
 void SP_trigger_push( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   InitTrigger( self );
 
   // unlike other triggers, we need to send this one to the client
@@ -243,6 +248,7 @@
 */
 void SP_target_push( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( !self->speed )
     self->speed = 1000;
 
@@ -319,6 +325,7 @@
 */
 void SP_trigger_teleport( gentity_t *self )
 {
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   InitTrigger( self );
 
   // unlike other triggers, we need to send this one to the client
@@ -372,10 +379,13 @@
 {
   int   dflags;
 
+  
   if( !other->takedamage )
     return;
-
-  if( self->timestamp > level.time )
+	
+	
+	
+  if( !(( (!(self->spawnflags & 16) &&  ((self->timestamp - FRAMETIME) == level.time)) || ((self->spawnflags & 16) &&  ((self->timestamp - 1000) == level.time)) || self->timestamp <= level.time) && other->hurt != level.time) )
     return;
 
   if( self->spawnflags & 16 )
@@ -393,10 +403,12 @@
     dflags = 0;
 
   G_Damage( other, self, self, NULL, NULL, self->damage, dflags, MOD_TRIGGER_HURT );
+  other->hurt = level.time;
 }
 
 void SP_trigger_hurt( gentity_t *self )
 {
+G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   InitTrigger( self );
 
   self->noise_index = G_SoundIndex( "sound/misc/electro.wav" );
@@ -407,12 +419,14 @@
 
   self->r.contents = CONTENTS_TRIGGER;
 
-  if( self->spawnflags & 2 )
+  //if( self->spawnflags & 2 ) // ==Troy== AMP seriously, this is strange, if you dont want to use it, just dont target it???
     self->use = hurt_use;
 
   // link in to the world if starting active
   if( !( self->spawnflags & 1 ) )
     trap_LinkEntity( self );
+  else
+	trap_UnlinkEntity( self );
 }
 
 
@@ -460,6 +474,8 @@
 
 void SP_func_timer( gentity_t *self )
 {
+G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+
   G_SpawnFloat( "random", "1", &self->random );
   G_SpawnFloat( "wait", "1", &self->wait );
 
@@ -520,6 +536,8 @@
 
 void SP_trigger_stage( gentity_t *self )
 {
+G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
+
   G_SpawnInt( "team", "0", (int *)&self->stageTeam );
   G_SpawnInt( "stage", "0", (int *)&self->stageStage );
 
@@ -541,6 +559,7 @@
 
 void SP_trigger_win( gentity_t *self )
 {
+G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   G_SpawnInt( "team", "0", (int *)&self->stageTeam );
 
   self->use = trigger_win;
@@ -549,6 +568,24 @@
 }
 
 
+
+void trigger_check_wait( gentity_t *self)
+{
+  if( self->wait > 0 )
+  {
+    self->think = multi_wait;
+    self->nextthink = level.time + ( self->wait + self->random * crandom( ) ) * 1000;
+  }
+  else
+  {
+    // we can't just remove (self) here, because this is a touch function
+    // called while looping through area links...
+    self->touch = 0;
+    self->nextthink = level.time + FRAMETIME;
+    self->think = G_FreeEntity;
+  }
+}
+
 /*
 ===============
 trigger_buildable_match
@@ -592,27 +629,19 @@
   if( self->s.eFlags & EF_DEAD )
   {
     if( !trigger_buildable_match( self, activator ) )
+	{
       G_UseTargets( self, activator );
+	  trigger_check_wait( self );
+	}
   }
   else
   {
     if( trigger_buildable_match( self, activator ) )
+	{
       G_UseTargets( self, activator );
+	  trigger_check_wait( self );
+	}
   }
-
-  if( self->wait > 0 )
-  {
-    self->think = multi_wait;
-    self->nextthink = level.time + ( self->wait + self->random * crandom( ) ) * 1000;
-  }
-  else
-  {
-    // we can't just remove (self) here, because this is a touch function
-    // called while looping through area links...
-    self->touch = 0;
-    self->nextthink = level.time + FRAMETIME;
-    self->think = G_FreeEntity;
-  }
 }
 
 /*
@@ -623,7 +652,7 @@
 void trigger_buildable_touch( gentity_t *ent, gentity_t *other, trace_t *trace )
 {
   //only triggered by buildables
-  if( other->s.eType != ET_BUILDABLE )
+  if( other->s.eType != ET_BUILDABLE || !other->spawned)
     return;
 
   trigger_buildable_trigger( ent, other );
@@ -647,6 +676,7 @@
 void SP_trigger_buildable( gentity_t *self )
 {
   char *buffer;
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
 
   G_SpawnFloat( "wait", "0.5", &self->wait );
   G_SpawnFloat( "random", "0", &self->random );
@@ -726,27 +756,20 @@
   if( self->s.eFlags & EF_DEAD )
   {
     if( !trigger_class_match( self, activator ) )
+	{
       G_UseTargets( self, activator );
+	  trigger_check_wait( self );
+	}
   }
   else
   {
     if( trigger_class_match( self, activator ) )
+	{
       G_UseTargets( self, activator );
+	  trigger_check_wait( self );
+	}
   }
 
-  if( self->wait > 0 )
-  {
-    self->think = multi_wait;
-    self->nextthink = level.time + ( self->wait + self->random * crandom( ) ) * 1000;
-  }
-  else
-  {
-    // we can't just remove (self) here, because this is a touch function
-    // called while looping through area links...
-    self->touch = 0;
-    self->nextthink = level.time + FRAMETIME;
-    self->think = G_FreeEntity;
-  }
 }
 
 /*
@@ -781,6 +804,7 @@
 void SP_trigger_class( gentity_t *self )
 {
   char *buffer;
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
 
   G_SpawnFloat( "wait", "0.5", &self->wait );
   G_SpawnFloat( "random", "0", &self->random );
@@ -866,27 +890,19 @@
   if( self->s.eFlags & EF_DEAD )
   {
     if( !trigger_equipment_match( self, activator ) )
+	{
       G_UseTargets( self, activator );
+	  trigger_check_wait( self );
+	}
   }
   else
   {
     if( trigger_equipment_match( self, activator ) )
+	{
       G_UseTargets( self, activator );
+	  trigger_check_wait( self );
+	}
   }
-
-  if( self->wait > 0 )
-  {
-    self->think = multi_wait;
-    self->nextthink = level.time + ( self->wait + self->random * crandom( ) ) * 1000;
-  }
-  else
-  {
-    // we can't just remove (self) here, because this is a touch function
-    // called while looping through area links...
-    self->touch = 0;
-    self->nextthink = level.time + FRAMETIME;
-    self->think = G_FreeEntity;
-  }
 }
 
 /*
@@ -921,6 +937,7 @@
 void SP_trigger_equipment( gentity_t *self )
 {
   char *buffer;
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
 
   G_SpawnFloat( "wait", "0.5", &self->wait );
   G_SpawnFloat( "random", "0", &self->random );
@@ -973,6 +990,7 @@
 */
 void trigger_gravity_use( gentity_t *ent, gentity_t *other, gentity_t *activator )
 {
+
   if( ent->r.linked )
     trap_UnlinkEntity( ent );
   else
@@ -988,7 +1006,7 @@
 void SP_trigger_gravity( gentity_t *self )
 {
   G_SpawnInt( "gravity", "800", &self->triggerGravity );
-
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   self->touch = trigger_gravity_touch;
   self->use = trigger_gravity_use;
 
@@ -1048,7 +1066,7 @@
 void SP_trigger_heal( gentity_t *self )
 {
   G_SpawnInt( "heal", "5", &self->damage );
-
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( self->damage <= 0 )
   {
     self->damage = 1;
@@ -1127,7 +1145,7 @@
 void SP_trigger_ammo( gentity_t *self )
 {
   G_SpawnInt( "ammo", "1", &self->damage );
-
+  G_SpawnInt( "gate", "255", &self->TargetGate ); //==Troy== AMP, specifies which input to trigger if targetting gate
   if( self->damage <= 0 )
   {
     self->damage = 1;
Index: src/game/bg_public.h
===================================================================
--- src/game/bg_public.h	(revision 92)
+++ src/game/bg_public.h	(working copy)
@@ -34,6 +34,9 @@
 
 #define VOTE_TIME               30000 // 30 seconds before vote times out
 
+#define MAX_TARGETS             4     // ==Troy== AMP WARNING! DO NOT CHANGE, if you will, also change the g_spawn.c to actually spawn extras
+#define MAX_TARGETNAMES         4     // ==Troy== AMP
+
 #define MINS_Z                  -24
 #define DEFAULT_VIEWHEIGHT      26
 #define CROUCH_VIEWHEIGHT       12
@@ -1036,6 +1039,7 @@
   qboolean  transparentTest;
   qboolean  reactorTest;
   qboolean  replaceable;
+
 } buildableAttributes_t;
 
 typedef struct
